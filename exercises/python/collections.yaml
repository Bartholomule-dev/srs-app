# exercises/python/collections.yaml
language: python
category: collections

exercises:
  # --- Lists Subconcept (additional) ---
  - slug: list-create-empty
    objective: Create an empty list using bracket notation
    title: Create Empty List
    difficulty: 1
    concept: collections
    subconcept: lists
    level: intro
    prereqs: [foundations]
    type: write
    pattern: construction
    prompt: Create an empty list called {{list_name}}
    expected_answer: "{{list_name}} = []"
    accepted_solutions:
      - "{{list_name}} = []"
      - "{{list_name}} = list()"
    hints:
      - Use empty square brackets []
      - Assign to the variable name {{list_name}}
    tags: [lists, creation, beginner]

  - slug: list-create-values
    objective: Create a list with initial values using literal syntax
    title: Create List with Values
    difficulty: 1
    concept: collections
    subconcept: lists
    level: intro
    prereqs: [foundations]
    type: write
    pattern: construction
    prompt: Create a list called {{list_name}} containing "{{item_example}}", "default", "test"
    expected_answer: '{{list_name}} = ["{{item_example}}", "default", "test"]'
    accepted_solutions:
      - '{{list_name}} = ["{{item_example}}", "default", "test"]'
      - "{{list_name}} = ['{{item_example}}', 'default', 'test']"
    hints:
      - Use square brackets for {{item_plural}}
      - Assign to {{list_name}} with = operator
      - Separate values with commas
    tags: [lists, creation, beginner]

  - slug: list-in-check
    objective: Use the in operator to check list membership
    title: List Membership
    difficulty: 1
    concept: collections
    subconcept: lists
    level: intro
    prereqs: [lists]
    type: write
    pattern: query
    prompt: Check if "{{item_example}}" is in {{list_name}}
    expected_answer: '"{{item_example}}" in {{list_name}}'
    accepted_solutions:
      - '"{{item_example}}" in {{list_name}}'
      - "'{{item_example}}' in {{list_name}}"
    hints:
      - Use the 'in' keyword between value and list
      - Returns True if found, False otherwise
    tags: [lists, membership, check]

  - slug: list-extend-method
    objective: Use extend() to add multiple elements from another iterable
    title: List Extend
    difficulty: 2
    concept: collections
    subconcept: lists
    level: practice
    prereqs: [lists]
    type: write
    pattern: mutation
    prompt: Extend {{list_name}} with {{item_plural}} from new_{{item_plural}}
    expected_answer: "{{list_name}}.extend(new_{{item_plural}})"
    accepted_solutions:
      - "{{list_name}}.extend(new_{{item_plural}})"
      - "{{list_name}} += new_{{item_plural}}"
    hints:
      - Use the extend() method
      - Adds all {{item_plural}} from new_{{item_plural}} to {{list_name}}
    tags: [lists, extend, mutation]

  # Static list-insert removed - covered by list-insert-dynamic

  - slug: list-pop-index
    objective: Use pop() to remove and return an element by index
    title: List Pop at Index
    difficulty: 2
    concept: collections
    subconcept: lists
    level: practice
    prereqs: [lists]
    type: write
    pattern: mutation
    prompt: Remove and return the {{item_singular}} at index 2 from {{list_name}}
    expected_answer: "{{list_name}}.pop(2)"
    accepted_solutions:
      - "{{list_name}}.pop(2)"
    hints:
      - Use pop() with the index as argument
      - pop() both removes and returns the {{item_singular}}
    tags: [lists, pop, mutation]

  - slug: list-index
    objective: Use index() to find the position of an element
    title: List Find Index
    difficulty: 2
    concept: collections
    subconcept: lists
    level: practice
    prereqs: [lists]
    type: write
    pattern: query
    prompt: Find the index of "{{item_example}}" in {{list_name}}
    expected_answer: '{{list_name}}.index("{{item_example}}")'
    accepted_solutions:
      - '{{list_name}}.index("{{item_example}}")'
      - "{{list_name}}.index('{{item_example}}')"
    hints:
      - Use the index() method with the {{item_singular}} to find
      - Returns the first position where the {{item_singular}} is found
      - Raises ValueError if the element is not in the list
    tags: [lists, index, query]

  - slug: list-count
    objective: Use count() to find how many times an element appears
    title: List Count
    difficulty: 2
    concept: collections
    subconcept: lists
    level: practice
    prereqs: [lists]
    type: write
    pattern: query
    prompt: Count occurrences of "{{item_example}}" in {{list_name}}
    expected_answer: '{{list_name}}.count("{{item_example}}")'
    accepted_solutions:
      - '{{list_name}}.count("{{item_example}}")'
      - "{{list_name}}.count('{{item_example}}')"
    hints:
      - Use the count() method with the {{item_singular}} to count
      - Returns 0 if not found, otherwise the count
    tags: [lists, count, query]

  - slug: list-sort
    objective: Use sort() to order list elements in place
    title: List Sort
    difficulty: 2
    concept: collections
    subconcept: lists
    level: practice
    prereqs: [lists]
    type: write
    pattern: mutation
    prompt: Sort {{list_name}} in place
    expected_answer: "{{list_name}}.sort()"
    accepted_solutions:
      - "{{list_name}}.sort()"
      - "{{list_name}}.sort( )"
    hints:
      - Use the sort() method
      - Modifies the list in place
    tags: [lists, sort, mutation]

  - slug: list-sorted
    objective: Use sorted() to create a new sorted list without modifying the original
    title: Sorted Copy
    difficulty: 2
    concept: collections
    subconcept: lists
    level: edge
    prereqs: [lists]
    type: write
    pattern: construction
    prompt: Return a sorted copy of {{list_name}} without modifying it
    expected_answer: "sorted({{list_name}})"
    accepted_solutions:
      - "sorted({{list_name}})"
      - "sorted( {{list_name}} )"
    hints:
      - Use sorted() function
      - Returns new list
    tags: [lists, sorted, copy]

  - slug: list-reverse
    objective: Use reverse() to reverse list order in place
    title: List Reverse
    difficulty: 2
    concept: collections
    subconcept: lists
    level: practice
    prereqs: [lists]
    type: write
    pattern: mutation
    prompt: Reverse {{list_name}} in place
    expected_answer: "{{list_name}}.reverse()"
    accepted_solutions:
      - "{{list_name}}.reverse()"
      - "{{list_name}}.reverse( )"
    hints:
      - Use the reverse() method on the list
      - Modifies the list in place (returns None)
    tags: [lists, reverse, mutation]

  # --- Tuples Subconcept ---
  - slug: tuple-create
    objective: Create a tuple using parentheses and comma-separated values
    title: Create Tuple
    difficulty: 1
    concept: collections
    subconcept: tuples
    level: intro
    prereqs: [foundations]
    type: write
    pattern: construction
    prompt: Create a {{item_singular}} tuple called {{item_singular}}_data with values 1, 2, 3
    expected_answer: "{{item_singular}}_data = (1, 2, 3)"
    accepted_solutions:
      - "{{item_singular}}_data = (1, 2, 3)"
      - "{{item_singular}}_data = (1,2,3)"
      - "{{item_singular}}_data = 1, 2, 3"
    hints:
      - Use parentheses for {{item_plural}}
      - Assign to {{item_singular}}_data with = operator
      - Separate with commas
    tags: [tuples, creation, beginner]

  - slug: tuple-single
    objective: Create a single-element tuple with trailing comma syntax
    title: Single Element Tuple
    difficulty: 2
    concept: collections
    subconcept: tuples
    level: practice
    prereqs: [tuples]
    type: write
    pattern: construction
    prompt: Create a single-{{item_singular}} tuple with element 5 (note the syntax)
    expected_answer: (5,)
    accepted_solutions:
      - (5,)
      - "5,"
    hints:
      - Need trailing comma for single {{item_singular}}
      - (5) is just the number 5
    tags: [tuples, creation, edge]

  - slug: tuple-unpack
    objective: Use tuple unpacking to assign multiple variables at once
    title: Tuple Unpacking
    difficulty: 2
    concept: collections
    subconcept: tuples
    level: practice
    prereqs: [tuples]
    type: write
    pattern: assignment
    prompt: Unpack tuple {{item_singular}}_coords = (3, 4) into variables {{attr_key_1}} and {{attr_key_2}}
    expected_answer: "{{attr_key_1}}, {{attr_key_2}} = {{item_singular}}_coords"
    accepted_solutions:
      - "{{attr_key_1}}, {{attr_key_2}} = {{item_singular}}_coords"
      - "({{attr_key_1}}, {{attr_key_2}}) = {{item_singular}}_coords"
    hints:
      - Variables go on left, tuple on right of =
      - Number of variables must match tuple length
    tags: [tuples, unpacking, assignment]

  - slug: tuple-index
    objective: Access tuple elements using index notation
    title: Tuple Indexing
    difficulty: 1
    concept: collections
    subconcept: tuples
    level: intro
    prereqs: [tuples]
    type: write
    pattern: indexing
    prompt: Get the second {{item_singular}} from tuple {{item_singular}}_data
    expected_answer: "{{item_singular}}_data[1]"
    accepted_solutions:
      - "{{item_singular}}_data[1]"
      - "{{item_singular}}_data[ 1 ]"
    hints:
      - Indices start at 0, so second {{item_singular}} is index 1
      - Use square brackets like lists
    tags: [tuples, indexing, access]

  # --- Dicts Subconcept ---
  - slug: dict-create-empty
    objective: Create an empty dictionary using brace notation
    title: Create Empty Dict
    difficulty: 1
    concept: collections
    subconcept: dicts
    level: intro
    prereqs: [foundations]
    type: write
    pattern: construction
    prompt: Create an empty dictionary called {{item_singular}}_data
    expected_answer: "{{item_singular}}_data = {}"
    accepted_solutions:
      - "{{item_singular}}_data = {}"
      - "{{item_singular}}_data = dict()"
    hints:
      - Use empty curly braces {}
      - Not the same as empty set (use set() for empty set)
    tags: [dicts, creation, beginner]

  - slug: dict-create-values
    objective: Create a dictionary with initial key-value pairs
    title: Create Dict with Values
    difficulty: 1
    concept: collections
    subconcept: dicts
    level: intro
    prereqs: [foundations]
    type: write
    pattern: construction
    prompt: |
      Create a dict called {{item_singular}}_info with key "{{attr_key_1}}" and value "{{item_example}}".
    expected_answer: '{{item_singular}}_info = {"{{attr_key_1}}": "{{item_example}}"}'
    accepted_solutions:
      - '{{item_singular}}_info = {"{{attr_key_1}}": "{{item_example}}"}'
      - "{{item_singular}}_info = {'{{attr_key_1}}': '{{item_example}}'}"
    hints:
      - "Use curly braces with key: value inside"
      - Assign the dict to the variable name
    tags: [dicts, creation, beginner]

  - slug: dict-bracket-access
    objective: Access dictionary values using bracket notation with keys
    title: Dict Access
    difficulty: 1
    concept: collections
    subconcept: dicts
    level: intro
    prereqs: [dicts]
    type: write
    pattern: indexing
    prompt: Get the value for key "{{attr_key_1}}" from {{item_singular}}
    expected_answer: '{{item_singular}}["{{attr_key_1}}"]'
    accepted_solutions:
      - '{{item_singular}}["{{attr_key_1}}"]'
      - "{{item_singular}}['{{attr_key_1}}']"
    hints:
      - Use square brackets with the key inside
      - Raises KeyError if key doesn't exist
    tags: [dicts, access, beginner]

  - slug: dict-get-default
    objective: Use get() to safely access values with a fallback default
    title: Dict Get with Default
    difficulty: 2
    concept: collections
    subconcept: dicts
    level: practice
    prereqs: [dicts]
    type: write
    pattern: query
    prompt: Get value for key "{{attr_key_2}}" from {{item_singular}}, returning None if not found
    expected_answer: '{{item_singular}}.get("{{attr_key_2}}")'
    accepted_solutions:
      - '{{item_singular}}.get("{{attr_key_2}}")'
      - "{{item_singular}}.get('{{attr_key_2}}')"
      - '{{item_singular}}.get("{{attr_key_2}}", None)'
      - "{{item_singular}}.get('{{attr_key_2}}', None)"
    hints:
      - Use get() method
      - Default is None when not specified
    tags: [dicts, get, safe-access]

  - slug: dict-set-item
    objective: Assign a value to a dictionary key using bracket notation
    title: Dict Set Value
    difficulty: 1
    concept: collections
    subconcept: dicts
    level: intro
    prereqs: [dicts]
    type: write
    pattern: mutation
    prompt: Set the key "{{attr_key_1}}" to value "{{item_example}}" in {{item_singular}}
    expected_answer: '{{item_singular}}["{{attr_key_1}}"] = "{{item_example}}"'
    accepted_solutions:
      - '{{item_singular}}["{{attr_key_1}}"] = "{{item_example}}"'
      - "{{item_singular}}['{{attr_key_1}}'] = '{{item_example}}'"
    hints:
      - Assignment with square brackets
      - Creates key if it doesn't exist
    tags: [dicts, update, mutation]

  - slug: dict-keys-method
    objective: Use keys() to retrieve a view of all keys from a dictionary
    title: Dict Keys View
    difficulty: 1
    concept: collections
    subconcept: dicts
    level: intro
    prereqs: [dicts]
    type: write
    pattern: query
    prompt: |
      Write an expression that returns a view of all keys from {{item_singular}}.
    expected_answer: "{{item_singular}}.keys()"
    accepted_solutions:
      - "{{item_singular}}.keys()"
      - "{{item_singular}}.keys( )"
    hints:
      - Use the keys() method
      - Returns a dict_keys view object (not a list)
      - You can iterate over it or convert to list() if needed
    tags: [dicts, keys, query]

  - slug: dict-values
    objective: Use values() to retrieve a view of all values from a dictionary
    title: Dict Values View
    difficulty: 1
    concept: collections
    subconcept: dicts
    level: intro
    prereqs: [dicts]
    type: write
    pattern: query
    prompt: |
      Write an expression that returns a view of all values from {{item_singular}}.
    expected_answer: "{{item_singular}}.values()"
    accepted_solutions:
      - "{{item_singular}}.values()"
      - "{{item_singular}}.values( )"
    hints:
      - Use the values() method
      - Returns a dict_values view object (not a list)
      - You can iterate over it or convert to list() if needed
    tags: [dicts, values, query]

  - slug: dict-items
    objective: Use items() to get a view of key-value pairs for iteration
    title: Dict Items View
    difficulty: 2
    concept: collections
    subconcept: dicts
    level: practice
    prereqs: [dicts]
    type: write
    pattern: query
    prompt: Get a view of all key-value pairs from {{item_singular}} as tuples
    expected_answer: "{{item_singular}}.items()"
    accepted_solutions:
      - "{{item_singular}}.items()"
      - "{{item_singular}}.items( )"
    hints:
      - Use the items() method
      - Returns a dict_items view of (key, value) tuples
      - Commonly used in for loops for iteration
    tags: [dicts, items, query]

  - slug: dict-pop
    objective: Use pop() to remove a key and return its value
    title: Dict Pop
    difficulty: 2
    concept: collections
    subconcept: dicts
    level: practice
    prereqs: [dicts]
    type: write
    pattern: mutation
    prompt: Remove and return the value for key "{{attr_key_1}}" from {{item_singular}}
    expected_answer: '{{item_singular}}.pop("{{attr_key_1}}")'
    accepted_solutions:
      - '{{item_singular}}.pop("{{attr_key_1}}")'
      - "{{item_singular}}.pop('{{attr_key_1}}')"
    hints:
      - Use the pop() method
      - Pop removes the key and returns its value
    tags: [dicts, pop, mutation]

  - slug: dict-in-check
    objective: Use the in operator to check if a key exists in a dictionary
    title: Dict Key Check
    difficulty: 1
    concept: collections
    subconcept: dicts
    level: intro
    prereqs: [dicts]
    type: write
    pattern: query
    prompt: |
      Write an expression that checks if key "{{attr_key_1}}" exists in {{item_singular}}.
      The expression should evaluate to True or False.
    expected_answer: '"{{attr_key_1}}" in {{item_singular}}'
    accepted_solutions:
      - '"{{attr_key_1}}" in {{item_singular}}'
      - "'{{attr_key_1}}' in {{item_singular}}"
    hints:
      - Use the 'in' keyword
      - Checks keys, not values
    tags: [dicts, membership, check]

  # --- Sets Subconcept ---
  - slug: set-create
    objective: Create a set with initial values using brace notation
    title: Create Set
    difficulty: 1
    concept: collections
    subconcept: sets
    level: intro
    prereqs: [foundations]
    type: write
    pattern: construction
    prompt: Create a set called {{item_singular}}_ids with values 1, 2, 3
    expected_answer: "{{item_singular}}_ids = {1, 2, 3}"
    accepted_solutions:
      - "{{item_singular}}_ids = {1, 2, 3}"
      - "{{item_singular}}_ids = {1,2,3}"
      - "{{item_singular}}_ids = {2, 1, 3}"
      - "{{item_singular}}_ids = {3, 2, 1}"
    hints:
      - Use curly braces for {{item_singular}} sets
      - Assign to {{item_singular}}_ids with = operator
      - Similar to dict but no colons for {{item_plural}}
    tags: [sets, creation, beginner]

  - slug: set-add
    objective: Use add() to insert a single element into a set
    title: Set Add
    difficulty: 1
    concept: collections
    subconcept: sets
    level: intro
    prereqs: [sets]
    type: write
    pattern: mutation
    prompt: Add "{{item_example}}" to set {{item_singular}}_ids
    expected_answer: '{{item_singular}}_ids.add("{{item_example}}")'
    accepted_solutions:
      - '{{item_singular}}_ids.add("{{item_example}}")'
      - "{{item_singular}}_ids.add('{{item_example}}')"
    hints:
      - Use the add() method for {{item_plural}}
      - Sets only store unique {{item_singular}} values
    tags: [sets, add, mutation]

  - slug: set-remove
    objective: Use remove() to delete an element with error on missing
    title: Set Remove
    difficulty: 2
    concept: collections
    subconcept: sets
    level: practice
    prereqs: [sets]
    type: write
    pattern: mutation
    prompt: Remove "{{item_example}}" from set {{item_singular}}_ids (raises error if not found)
    expected_answer: '{{item_singular}}_ids.remove("{{item_example}}")'
    accepted_solutions:
      - '{{item_singular}}_ids.remove("{{item_example}}")'
      - "{{item_singular}}_ids.remove('{{item_example}}')"
    hints:
      - Use the remove() method for {{item_plural}}
      - Use discard() if you want to avoid {{item_singular}} KeyError
    tags: [sets, remove, mutation]

  - slug: set-discard
    objective: Use discard() to safely remove an element without raising errors
    title: Set Discard
    difficulty: 2
    concept: collections
    subconcept: sets
    level: practice
    prereqs: [sets]
    type: write
    pattern: mutation
    prompt: Remove "{{item_example}}" from set {{item_singular}}_ids if present (no error if not found)
    expected_answer: '{{item_singular}}_ids.discard("{{item_example}}")'
    accepted_solutions:
      - '{{item_singular}}_ids.discard("{{item_example}}")'
      - "{{item_singular}}_ids.discard('{{item_example}}')"
    hints:
      - Use the discard() method for {{item_plural}}
      - Safer than remove() for {{item_singular}} operations
    tags: [sets, discard, mutation]

  - slug: set-union
    objective: Apply set union to combine elements from two sets
    title: Set Union
    difficulty: 2
    concept: collections
    subconcept: sets
    level: practice
    prereqs: [sets]
    type: write
    pattern: construction
    prompt: Get the union of {{item_singular}} sets a and b
    expected_answer: a | b
    accepted_solutions:
      - a | b
      - a.union(b)
    hints:
      - Use | operator for {{item_plural}}
      - Or union() method
    tags: [sets, union, operation]

  - slug: set-intersection
    objective: Apply set intersection to find common elements
    title: Set Intersection
    difficulty: 2
    concept: collections
    subconcept: sets
    level: practice
    prereqs: [sets]
    type: write
    pattern: construction
    prompt: Get the intersection of {{item_singular}} sets a and b
    expected_answer: a & b
    accepted_solutions:
      - a & b
      - a.intersection(b)
    hints:
      - Use & operator for {{item_plural}}
      - "{{item_singular}} elements in both sets"
    tags: [sets, intersection, operation]

  - slug: set-difference
    objective: Apply set difference to find elements unique to one set
    title: Set Difference
    difficulty: 2
    concept: collections
    subconcept: sets
    level: practice
    prereqs: [sets]
    type: write
    pattern: construction
    prompt: Get {{item_plural}} in set a but not in set b
    expected_answer: a - b
    accepted_solutions:
      - a - b
      - a.difference(b)
    hints:
      - Use - operator for {{item_singular}} difference
      - Or use difference() method for {{item_plural}}
    tags: [sets, difference, operation]

  # --- Unpacking Subconcept ---
  # Moved from foundations - multiple value assignment
  - slug: multiple-assignment
    objective: Use tuple unpacking to initialize multiple values at once
    title: Multiple Values
    difficulty: 1
    concept: collections
    subconcept: unpacking
    level: intro
    prereqs: [tuples]
    type: write
    pattern: assignment
    prompt: In a single line, assign `"{{item_example}}"`, `1`, and `True` to `{{item_singular}}`, `{{item_singular}}_id`, and `{{status_var}}`
    expected_answer: '{{item_singular}}, {{item_singular}}_id, {{status_var}} = "{{item_example}}", 1, True'
    accepted_solutions:
      - '{{item_singular}}, {{item_singular}}_id, {{status_var}} = "{{item_example}}", 1, True'
      - "{{item_singular}}, {{item_singular}}_id, {{status_var}} = '{{item_example}}', 1, True"
    hints:
      - Separate variables with commas
      - Match the number of values
    tags: [unpacking, assignment]

  # Moved from foundations - variable swap
  - slug: swap-variables
    objective: Swap two variable values using Pythonic tuple unpacking
    title: Swap Values
    difficulty: 1
    concept: collections
    subconcept: unpacking
    level: intro
    prereqs: [unpacking]
    type: write
    pattern: swap
    prompt: Swap `current_{{item_singular}}` and `next_{{item_singular}}` using tuple unpacking (no temp variable)
    expected_answer: "current_{{item_singular}}, next_{{item_singular}} = next_{{item_singular}}, current_{{item_singular}}"
    accepted_solutions:
      - "current_{{item_singular}}, next_{{item_singular}} = next_{{item_singular}}, current_{{item_singular}}"
      - "next_{{item_singular}}, current_{{item_singular}} = current_{{item_singular}}, next_{{item_singular}}"
      - "(current_{{item_singular}}, next_{{item_singular}}) = (next_{{item_singular}}, current_{{item_singular}})"
    hints:
      - Python allows simultaneous assignment
      - No temp variable needed
    tags: [unpacking, swap]

  - slug: unpacking-intro
    objective: Unpack a tuple into individual variables
    title: Basic Tuple Unpacking
    difficulty: 1
    concept: collections
    subconcept: unpacking
    level: intro
    prereqs: [tuples]
    type: write
    pattern: assignment
    prompt: Unpack the {{item_singular}} tuple point = (3, 5) into variables x and y
    expected_answer: "x, y = point"
    accepted_solutions:
      - "x, y = point"
      - "(x, y) = point"
    hints:
      - "{{item_singular}} variables on the left, tuple on the right"
      - Number of {{item_singular}} variables must match tuple length
    tags: [unpacking, intro, tuples]

  - slug: unpacking-list-intro
    objective: Unpack a list into individual variables
    title: List Unpacking
    difficulty: 1
    concept: collections
    subconcept: unpacking
    level: intro
    prereqs: [lists]
    type: write
    pattern: assignment
    prompt: Unpack {{list_name}} = ["red", "green", "blue"] into variables a, b, c
    expected_answer: "a, b, c = {{list_name}}"
    accepted_solutions:
      - "a, b, c = {{list_name}}"
      - "(a, b, c) = {{list_name}}"
      - "a,b,c = {{list_name}}"
    hints:
      - Same syntax as tuple unpacking
      - Works with any iterable
      - Parentheses around the variables are optional
    tags: [unpacking, intro, lists]

  - slug: unpacking-swap-intro
    objective: Use unpacking to swap two variables
    title: Variable Swap
    difficulty: 1
    concept: collections
    subconcept: unpacking
    level: intro
    prereqs: [unpacking]
    type: write
    pattern: assignment
    prompt: Swap the {{item_singular}} values of variables a and b using unpacking (one line)
    expected_answer: "a, b = b, a"
    accepted_solutions:
      - "a, b = b, a"
    hints:
      - Python evaluates the right side first for {{item_plural}}
      - No temp {{item_singular}} variable needed
    tags: [unpacking, intro, swap]

  - slug: star-unpack
    objective: Use star unpacking to capture remaining elements into a list
    title: Star Unpacking
    difficulty: 2
    concept: collections
    subconcept: unpacking
    level: edge
    prereqs: [lists, tuples]
    type: write
    pattern: assignment
    prompt: Unpack first {{item_singular}} to a, rest to remaining from list [1, 2, 3, 4]
    expected_answer: a, *remaining = [1, 2, 3, 4]
    accepted_solutions:
      - a, *remaining = [1, 2, 3, 4]
    hints:
      - Use * for rest {{item_plural}}
      - remaining will contain the other {{item_plural}}
    tags: [unpacking, star, advanced]

  - slug: unpack-function-args
    objective: Use star operator to unpack a list as positional arguments
    title: Unpack into Function
    difficulty: 2
    concept: collections
    subconcept: unpacking
    level: edge
    prereqs: [lists]
    type: write
    pattern: construction
    prompt: Call {{action_verb}}_{{item_singular}} with list args unpacked as positional arguments
    expected_answer: "{{action_verb}}_{{item_singular}}(*args)"
    accepted_solutions:
      - "{{action_verb}}_{{item_singular}}(*args)"
    hints:
      - Use * to unpack {{item_singular}} list
      - Turns [1, 2, 3] into {{action_verb}}_{{item_singular}}(1, 2, 3)
    tags: [unpacking, function, splat]

  - slug: unpack-dict-kwargs
    objective: Use double-star operator to unpack a dict as keyword arguments
    title: Unpack Dict to Kwargs
    difficulty: 2
    concept: collections
    subconcept: unpacking
    level: edge
    prereqs: [dicts]
    type: write
    pattern: construction
    prompt: Call {{action_verb}}_{{item_singular}} with dict kwargs unpacked as keyword arguments
    expected_answer: "{{action_verb}}_{{item_singular}}(**kwargs)"
    accepted_solutions:
      - "{{action_verb}}_{{item_singular}}(**kwargs)"
    hints:
      - Use ** to unpack {{item_singular}} dict
      - 'Turns {"{{attr_key_1}}": 1} into {{action_verb}}_{{item_singular}}({{attr_key_1}}=1)'
    tags: [unpacking, function, kwargs]

  # --- Mutability Subconcept ---
  - slug: mutable-default-trap
    objective: Recognize and avoid mutable default argument issues
    title: Mutable Default Trap
    difficulty: 2
    concept: collections
    subconcept: mutability
    level: edge
    prereqs: [lists, fn-basics]
    type: write
    pattern: definition
    prompt: Define append_{{item_singular}}({{item_singular}}, target=None) avoiding mutable default
    expected_answer: |
      def append_{{item_singular}}({{item_singular}}, target=None):
          if target is None:
              target = []
          target.append({{item_singular}})
          return target
    accepted_solutions:
      - |
    hints:
      - Never use [] or {} as default for {{item_plural}}
      - Use None and create {{item_singular}} list inside function
    tags: [mutability, lists, functions]

  - slug: list-aliasing
    objective: Demonstrate understanding of list aliasing behavior
    title: List Aliasing
    difficulty: 2
    concept: collections
    subconcept: mutability
    level: intro
    prereqs: [lists]
    type: write
    pattern: assignment
    prompt: Create {{item_singular}}_copy that references the same list as {{list_name}} (not a copy)
    expected_answer: "{{item_singular}}_copy = {{list_name}}"
    accepted_solutions:
      - "{{item_singular}}_copy = {{list_name}}"
    hints:
      - Simple assignment creates an alias for {{item_plural}}
      - Both {{item_singular}} names point to same object
    tags: [mutability, lists, aliasing]

  - slug: shallow-copy-method
    objective: Create a shallow copy of a list using the copy method
    title: Shallow Copy with .copy()
    difficulty: 2
    concept: collections
    subconcept: mutability
    level: practice
    prereqs: [lists, mutability]
    type: write
    pattern: construction
    prompt: Create a shallow copy of {{list_name}} using the copy method
    expected_answer: "{{list_name}}.copy()"
    accepted_solutions:
      - "{{list_name}}.copy()"
    hints:
      - Use the .copy() method
      - Returns a new list with same {{item_plural}}
    tags: [mutability, lists, copy]

  - slug: shallow-copy-constructor
    objective: Create a shallow copy of a list using the list constructor
    title: Shallow Copy with list()
    difficulty: 2
    concept: collections
    subconcept: mutability
    level: practice
    prereqs: [lists, mutability]
    type: write
    pattern: construction
    prompt: Create a shallow copy of {{list_name}} using the list constructor
    expected_answer: "list({{list_name}})"
    accepted_solutions:
      - "list({{list_name}})"
    hints:
      - Pass list to list() constructor
      - Creates new list from existing
    tags: [mutability, lists, copy]

  - slug: deep-copy
    objective: Create a deep copy of a nested structure using copy.deepcopy
    title: Deep Copy
    difficulty: 3
    concept: collections
    subconcept: mutability
    level: practice
    prereqs: [lists, mutability, imports]
    type: write
    pattern: construction
    prompt: |
      Create a deep copy of nested {{list_name}} using the copy module.
      (Assume `import copy` is already done)
    expected_answer: "copy.deepcopy({{list_name}})"
    accepted_solutions:
      - "copy.deepcopy({{list_name}})"
      - "copy.deepcopy( {{list_name}} )"
    hints:
      - Use copy.deepcopy() for nested structures
      - Deep copy creates independent copies of all nested objects
      - Unlike shallow copy, changes to nested items won't affect the original
    tags: [mutability, lists, deep-copy]

  - slug: mutate-vs-reassign
    objective: Distinguish between in-place mutation and variable reassignment
    title: Mutate in Place vs Reassign
    difficulty: 3
    concept: collections
    subconcept: mutability
    level: edge
    prereqs: [lists, mutability]
    type: write
    pattern: mutation
    prompt: |
      Extend {{list_name}} in place with items from new_{{item_plural}}.
      Do not reassign the variable - mutate the existing list.
    expected_answer: "{{list_name}}.extend(new_{{item_plural}})"
    accepted_solutions:
      - "{{list_name}}.extend(new_{{item_plural}})"
      - "{{list_name}} += new_{{item_plural}}"
    hints:
      - Use extend() or += for in-place mutation
      - Reassigning (=) creates a new list object
      - Other references to the list won't see changes if you reassign
    tags: [mutability, lists, in-place]

  - slug: tuple-immutability
    objective: Understand that tuples cannot be modified after creation
    title: Tuple Immutability
    difficulty: 2
    concept: collections
    subconcept: mutability
    level: edge
    prereqs: [tuples, mutability]
    type: write
    pattern: construction
    prompt: Create new {{item_singular}} tuple by concatenating t with (4, 5) since tuples are immutable
    expected_answer: t + (4, 5)
    accepted_solutions:
      - t + (4, 5)
    hints:
      - Cannot modify {{item_singular}} tuple in place
      - Must create new {{item_singular}} tuple via concatenation
    tags: [mutability, tuples, immutable]

  - slug: dict-mutable-values
    objective: Recognize that dictionary values can be mutable objects
    title: Dict with Mutable Values
    difficulty: 3
    concept: collections
    subconcept: mutability
    level: edge
    prereqs: [dicts, lists, mutability]
    type: write
    pattern: mutation
    prompt: Append {{item_singular}} ID 3 to the list stored at key "{{attr_key_1}}" in dict d
    expected_answer: 'd["{{attr_key_1}}"].append(3)'
    accepted_solutions:
      - 'd["{{attr_key_1}}"].append(3)'
      - "d['{{attr_key_1}}'].append(3)"
    hints:
      - Access the {{item_singular}} list first with d["{{attr_key_1}}"]
      - Then call append on that {{item_plural}} list
    tags: [mutability, dicts, lists]

  # --- Fill-in Exercises ---
  - slug: list-bracket-fill
    objective: Complete list literal syntax
    title: List Bracket Fill-in
    difficulty: 1
    concept: collections
    subconcept: lists
    level: intro
    prereqs: []
    type: fill-in
    blank_position: 0
    pattern: construction
    prompt: Fill in the opening bracket for a {{item_singular}} list
    template: "{{list_name}} = ___1, 2, 3]"
    expected_answer: "["
    hints:
      - Opening bracket for {{item_plural}} lists
      - Lists use square brackets []
    tags: [lists, syntax, fill-in]

  - slug: dict-brace-fill
    objective: Complete dict literal syntax
    title: Dict Brace Fill-in
    difficulty: 1
    concept: collections
    subconcept: dicts
    level: intro
    prereqs: []
    type: fill-in
    blank_position: 0
    pattern: construction
    prompt: Fill in the opening brace for a {{item_singular}} dict
    template: '{{item_singular}}_data = ___"{{attr_key_1}}": "{{item_example}}"}'
    expected_answer: "{"
    hints:
      - Opening brace for {{item_singular}} dicts
      - Dicts use curly braces {}
    tags: [dicts, syntax, fill-in]

  - slug: in-operator-fill
    objective: Complete membership test
    title: In Operator Fill-in
    difficulty: 1
    concept: collections
    subconcept: lists
    level: intro
    prereqs: [lists]
    type: fill-in
    blank_position: 0
    pattern: query
    prompt: Fill in the {{item_singular}} membership operator
    template: '"{{item_example}}" ___ {{list_name}}'
    expected_answer: "in"
    hints:
      - "{{item_singular}} membership test operator"
      - Returns True or False
    tags: [collections, in, fill-in]

  # --- Predict Exercises ---
  - slug: list-append-predict
    objective: Predict list after append
    title: List Append Predict
    difficulty: 1
    concept: collections
    subconcept: lists
    level: intro
    prereqs: [lists]
    type: predict
    grading_strategy: execution
    pattern: mutation
    prompt: What does this list append code print?
    code: |
      {{list_name}} = [1, 2]
      {{list_name}}.append(3)
      print({{list_name}})
    expected_answer: "[1, 2, 3]"
    accepted_solutions:
      - "[1, 2, 3]"
      - "[1,2,3]"
    hints:
      - append adds {{item_singular}} to the end
      - Modifies the list in place
    tags: [lists, append, predict]

  - slug: dict-get-predict
    objective: Predict dict.get with default
    title: Dict Get Predict
    difficulty: 2
    concept: collections
    subconcept: dicts
    level: practice
    prereqs: [dicts]
    type: predict
    grading_strategy: execution
    pattern: lookup
    prompt: What does this dict.get() code print?
    code: |
      {{item_singular}}_data = {"{{attr_key_1}}": 1}
      print({{item_singular}}_data.get("{{attr_key_2}}", 0))
    expected_answer: "0"
    hints:
      - get returns default if {{item_singular}} key missing
      - Key "{{attr_key_2}}" is not in the dict
    tags: [dicts, get, predict]

  - slug: set-union-predict
    objective: Predict set union result
    title: Set Union Predict
    difficulty: 2
    concept: collections
    subconcept: sets
    level: practice
    prereqs: [sets]
    type: predict
    grading_strategy: execution
    pattern: construction
    prompt: |
      What does this set union code print?
      (Enter the set contents - any order is fine since sets are unordered)
    code: |
      {{item_singular}}_set_a = {1, 2}
      {{item_singular}}_set_b = {2, 3}
      print({{item_singular}}_set_a | {{item_singular}}_set_b)
    expected_answer: "{1, 2, 3}"
    accepted_solutions:
      - "{1, 2, 3}"
      - "{1,2,3}"
      - "{1, 3, 2}"
      - "{1,3,2}"
      - "{2, 1, 3}"
      - "{2,1,3}"
      - "{2, 3, 1}"
      - "{2,3,1}"
      - "{3, 1, 2}"
      - "{3,1,2}"
      - "{3, 2, 1}"
      - "{3,2,1}"
    hints:
      - Union combines all unique elements from both sets
      - Duplicates (like 2) appear only once
      - Set display order may vary - focus on the elements
    tags: [sets, union, predict]

  # --- Dynamic Exercises ---
  - slug: list-indexing-dynamic
    objective: Use bracket notation to access list elements
    title: Dynamic List Indexing
    difficulty: 1
    prompt: "Given {{list_name}} = [{{a}}, {{b}}, {{c}}], what does {{list_name}}[1] return?"
    expected_answer: "{{b}}"
    hints:
      - List indices start at 0
      - "{{list_name}}[1] returns the second element"
    tags: [lists, indexing, dynamic]
    concept: collections
    subconcept: lists
    level: intro
    prereqs: []
    type: predict
    grading_strategy: execution
    pattern: indexing
    generator: list-values
    code: |
      {{list_name}} = [{{a}}, {{b}}, {{c}}]
      print({{list_name}}[1])

  - slug: list-sum-dynamic
    objective: Predict the output of adding two numbers
    title: Dynamic Addition
    difficulty: 2
    prompt: "Given x = {{x}} and y = {{y}}, what does x + y print?"
    expected_answer: "{{sum}}"
    hints:
      - Addition is straightforward arithmetic
      - Just add {{x}} + {{y}}
    tags: [arithmetic, dynamic]
    concept: numbers-booleans
    subconcept: integers
    level: practice
    prereqs: []
    type: predict
    grading_strategy: execution
    pattern: arithmetic
    generator: arithmetic-values
    code: |
      x = {{x}}
      y = {{y}}
      print(x + y)

  - slug: list-slice-write-dynamic
    objective: Write slice syntax to extract elements from index start to end
    title: Dynamic List Slice Write
    difficulty: 2
    prompt: "Extract elements from index {{start}} to {{end}} (exclusive) from {{list_name}}"
    expected_answer: "{{list_name}}[{{start}}:{{end}}]"
    accepted_solutions:
      - "{{list_name}}[{{start}}:{{end}}]"
    hints:
      - List slicing uses [start:end] syntax
      - The end index is exclusive
    tags: [lists, slicing, dynamic]
    concept: collections
    subconcept: lists
    level: practice
    prereqs: [lists]
    type: write
    pattern: slicing
    generator: slice-bounds
    target_construct:
      type: slice
      feedback: "Try using slice notation [start:end] for extracting a range of elements"

  - slug: list-negative-index-dynamic
    objective: Use negative indexing to access list elements from the end
    title: Dynamic Negative Index
    difficulty: 2
    prompt: "Given {{list_name}} = [{{a}}, {{b}}, {{c}}], what does {{list_name}}[-1] return?"
    expected_answer: "{{c}}"
    hints:
      - Negative indices count from the end
      - "{{list_name}}[-1] is the last element"
    tags: [lists, indexing, negative, dynamic]
    concept: collections
    subconcept: lists
    level: practice
    prereqs: [lists]
    type: predict
    grading_strategy: execution
    pattern: indexing
    generator: list-values
    code: |
      {{list_name}} = [{{a}}, {{b}}, {{c}}]
      print({{list_name}}[-1])

  - slug: list-len-dynamic
    objective: Predict the length of a list
    title: Dynamic List Length
    difficulty: 1
    prompt: "Given {{list_name}} = [{{a}}, {{b}}, {{c}}], what does len({{list_name}}) return?"
    expected_answer: "3"
    hints:
      - len() returns the number of elements
      - "Count how many {{item_plural}} are in the list"
    tags: [lists, len, dynamic]
    concept: collections
    subconcept: lists
    level: intro
    prereqs: [lists]
    type: predict
    grading_strategy: execution
    pattern: query
    generator: list-values
    code: |
      {{list_name}} = [{{a}}, {{b}}, {{c}}]
      print(len({{list_name}}))

  - slug: list-append-dynamic
    objective: Predict the result of appending an element to a list
    title: Dynamic List Append
    difficulty: 2
    prompt: "Given {{list_name}} = [{{a}}, {{b}}], what is {{list_name}} after {{list_name}}.append({{c}})?"
    expected_answer: "[{{a}}, {{b}}, {{c}}]"
    hints:
      - "append() adds a {{item_singular}} to the end"
      - The list is modified in place
    tags: [lists, append, mutation, dynamic]
    concept: collections
    subconcept: lists
    level: practice
    prereqs: [lists]
    type: predict
    grading_strategy: execution
    pattern: mutation
    generator: list-values
    code: |
      {{list_name}} = [{{a}}, {{b}}]
      {{list_name}}.append({{c}})
      print({{list_name}})

  - slug: list-pop-dynamic
    objective: Predict the value returned when popping from a list
    title: Dynamic List Pop
    difficulty: 2
    prompt: "Given {{list_name}} = [{{a}}, {{b}}, {{c}}], what does {{list_name}}.pop() return?"
    expected_answer: "{{c}}"
    hints:
      - "pop() removes and returns the last {{item_singular}}"
      - The last element is {{c}}
    tags: [lists, pop, mutation, dynamic]
    concept: collections
    subconcept: lists
    level: practice
    prereqs: [lists]
    type: predict
    grading_strategy: execution
    pattern: mutation
    generator: list-values
    code: |
      {{list_name}} = [{{a}}, {{b}}, {{c}}]
      print({{list_name}}.pop())

  - slug: list-access-index-dynamic
    objective: Write bracket notation to access a list element by index
    title: Dynamic List Access
    difficulty: 1
    prompt: "Get the {{item_singular}} at index {{idx}} from {{list_name}}"
    expected_answer: "{{list_name}}[{{idx}}]"
    accepted_solutions:
      - "{{list_name}}[{{idx}}]"
      - "{{list_name}}[ {{idx}} ]"
    hints:
      - Use square bracket notation
      - Indices start at 0
    tags: [lists, indexing, dynamic]
    concept: collections
    subconcept: lists
    level: intro
    prereqs: [lists]
    type: write
    pattern: indexing
    generator: index-values

  - slug: dict-access-dynamic
    objective: Predict the result of dict key access
    title: Dynamic Dict Access
    difficulty: 1
    concept: collections
    subconcept: dicts
    level: intro
    prereqs: [dicts]
    type: predict
    grading_strategy: execution
    pattern: indexing
    generator: dict-values
    prompt: 'Given d = {{dict_str}}, what does d["{{key}}"] return?'
    code: |
      d = {{dict_str}}
      print(d["{{key}}"])
    expected_answer: "{{value}}"
    hints:
      - Look up the key in the dictionary
      - If key doesn't exist, it raises KeyError
    tags: [collections, dicts, dynamic]

  - slug: list-insert-dynamic
    objective: Use insert() to add an element at a specific position
    title: Dynamic List Insert
    difficulty: 2
    concept: collections
    subconcept: lists
    level: practice
    prereqs: [lists]
    type: write
    pattern: mutation
    generator: index-values
    prompt: 'Insert a new {{item_singular}} "x" at index {{idx}} in {{list_name}}'
    expected_answer: '{{list_name}}.insert({{idx}}, "x")'
    accepted_solutions:
      - '{{list_name}}.insert({{idx}}, "x")'
      - "{{list_name}}.insert({{idx}}, 'x')"
    hints:
      - insert(index, value)
      - "{{item_plural}} at or after index shift right"
    tags: [lists, insert, mutation, dynamic]

  - slug: list-method-predict-dynamic
    objective: Predict the result of a list method or builtin function call
    title: Dynamic List Method Result
    difficulty: 2
    concept: collections
    subconcept: lists
    level: practice
    prereqs: [lists]
    type: predict
    grading_strategy: execution
    pattern: query
    generator: list-method
    prompt: "What does this code print?"
    code: "{{code}}"
    expected_answer: "{{result}}"
    hints:
      - "The {{method}}() {{description}}"
      - "Apply the method to understand what it returns"
    tags: [lists, methods, dynamic]

  - slug: nested-access-predict-dynamic
    objective: Predict the result of accessing nested data structures
    title: Dynamic Nested Access
    difficulty: 2
    concept: collections
    subconcept: dicts
    level: practice
    prereqs: [dicts, lists]
    type: predict
    grading_strategy: execution
    pattern: indexing
    generator: nested-access
    prompt: "What does this code print?"
    code: "{{code}}"
    expected_answer: "{{result}}"
    hints:
      - "This is a {{description}}"
      - "Use bracket notation for both list indices and dict keys"
    tags: [collections, nested, dynamic]

  - slug: nested-access-write-dynamic
    objective: Write code to access a specific value in a nested structure
    title: Dynamic Nested Access Write
    difficulty: 2
    concept: collections
    subconcept: dicts
    level: practice
    prereqs: [dicts, lists]
    type: write
    pattern: indexing
    generator: nested-access
    prompt: |
      Given {{varName}} = {{dataStr}}, write an expression to access the value {{result}}.
    expected_answer: "{{accessExpr}}"
    accepted_solutions:
      - "{{accessExpr}}"
    hints:
      - "This is a {{description}}"
      - "Chain bracket notation: dict keys use strings, list indices use integers"
    tags: [collections, nested, dynamic]

  # --- Dynamic Tuple Exercises ---
  - slug: tuple-index-dynamic
    objective: Access a tuple element by index
    title: Dynamic Tuple Index
    difficulty: 2
    concept: collections
    subconcept: tuples
    level: practice
    prereqs: [tuples]
    type: predict
    grading_strategy: execution
    pattern: indexing
    generator: tuple-access
    prompt: "What does {{tupleVar}}[{{index}}] return?"
    code: |
      {{tupleVar}} = {{tuple}}
      print({{tupleVar}}[{{index}}])
    expected_answer: "{{result}}"
    hints:
      - Tuple indexing works like list indexing
      - Index {{index}} gets the element at position {{index}}
    tags: [tuples, indexing, dynamic]

  - slug: tuple-unpack-dynamic
    objective: Write unpacking for a dynamically generated tuple
    title: Dynamic Tuple Unpack
    difficulty: 2
    concept: collections
    subconcept: unpacking
    level: practice
    prereqs: [unpacking]
    type: write
    pattern: assignment
    generator: tuple-access
    prompt: |
      Given {{tupleVar}} = {{tuple}}, unpack it into 3 variables (a, b, c).
    expected_answer: "a, b, c = {{tupleVar}}"
    accepted_solutions:
      - "a, b, c = {{tupleVar}}"
      - "x, y, z = {{tupleVar}}"
      - "(a, b, c) = {{tupleVar}}"
      - "(x, y, z) = {{tupleVar}}"
      - "a,b,c = {{tupleVar}}"
      - "x,y,z = {{tupleVar}}"
    hints:
      - Number of variables must match tuple length (3)
      - Use comma-separated variable names on the left of =
      - Parentheses around the variables are optional
    tags: [tuples, unpacking, dynamic]

  # --- Dynamic Set Exercises ---
  - slug: set-operation-dynamic
    objective: Predict the result of a set operation
    title: Dynamic Set Operation
    difficulty: 2
    concept: collections
    subconcept: sets
    level: practice
    prereqs: [sets]
    type: predict
    grading_strategy: execution
    pattern: logical
    generator: set-ops
    prompt: |
      What does {{code}} return?
      (Enter the set contents - any order is fine since sets are unordered)
    code: "{{code}}"
    expected_answer: "{{result}}"
    hints:
      - "{{description}}"
      - The {{operationName}} operation uses {{operation}}
      - Set element order may vary in output
    tags: [sets, operations, dynamic]

  - slug: set-operation-write-dynamic
    objective: Write the set operation to get a specific result
    title: Write Set Operation
    difficulty: 2
    concept: collections
    subconcept: sets
    level: practice
    prereqs: [sets]
    type: write
    pattern: logical
    generator: set-ops
    prompt: "Write the {{operationName}} of {{set1}} and {{set2}}"
    expected_answer: "{{set1}} {{operation}} {{set2}}"
    accepted_solutions:
      - "{{set1}} {{operation}} {{set2}}"
    hints:
      - "{{operationName}} uses the {{operation}} operator"
      - "Place the operator between the two sets"
    tags: [sets, operations, dynamic, write]

  # --- Dict Iteration Subconcept ---
  - slug: dict-items-loop
    objective: Iterate over key-value pairs using .items()
    title: Dict Items Loop
    difficulty: 2
    concept: collections
    subconcept: dict-iteration
    level: intro
    prereqs: [dicts]
    type: write
    pattern: iteration
    prompt: |
      Write a for loop that prints each key and value from a dict called {{item_singular}}_data.
      Use .items() to get both. Each print should output: key value (space-separated)
    expected_answer: |
      for key, value in {{item_singular}}_data.items():
          print(key, value)
    accepted_solutions:
      - |
        for key, value in {{item_singular}}_data.items():
            print(key, value)
      - |
        for k, v in {{item_singular}}_data.items():
            print(k, v)
      - |
        for name, val in {{item_singular}}_data.items():
            print(name, val)
      - |
        for item, value in {{item_singular}}_data.items():
            print(item, value)
      - |
        for x, y in {{item_singular}}_data.items():
            print(x, y)
      - |
        for a, b in {{item_singular}}_data.items():
            print(a, b)
      - |
        for key, value in {{item_singular}}_data.items():
            print(f"{key} {value}")
      - |
        for k, v in {{item_singular}}_data.items():
            print(f"{k} {v}")
    hints:
      - .items() returns key-value pairs as tuples
      - Unpack into two loop variables
      - "print(key, value) or print(f\"{key} {value}\") both work"
    tags: [dicts, iteration, items]

  - slug: dict-keys-loop
    objective: Iterate over dictionary keys
    title: Dict Keys Loop
    difficulty: 2
    concept: collections
    subconcept: dict-iteration
    level: intro
    prereqs: [dicts]
    type: write
    pattern: iteration
    prompt: |
      Write a for loop that prints each key from a dict called {{item_singular}}_config.
      Print one key per line.
    expected_answer: |
      for key in {{item_singular}}_config:
          print(key)
    accepted_solutions:
      - |
        for key in {{item_singular}}_config:
            print(key)
      - |
        for key in {{item_singular}}_config.keys():
            print(key)
      - |
        for k in {{item_singular}}_config:
            print(k)
      - |
        for k in {{item_singular}}_config.keys():
            print(k)
      - |
        for name in {{item_singular}}_config:
            print(name)
      - |
        for item in {{item_singular}}_config:
            print(item)
      - |
        for x in {{item_singular}}_config:
            print(x)
    hints:
      - Iterating a dict directly gives you its keys
      - .keys() is optional but makes intent explicit
    tags: [dicts, iteration, keys]

  - slug: dict-values-loop
    objective: Iterate over dictionary values
    title: Dict Values Loop
    difficulty: 2
    concept: collections
    subconcept: dict-iteration
    level: intro
    prereqs: [dicts]
    type: write
    pattern: iteration
    prompt: |
      Write a for loop that prints each value from a dict called {{item_singular}}_scores.
      Print one value per line.
    expected_answer: |
      for value in {{item_singular}}_scores.values():
          print(value)
    accepted_solutions:
      - |
        for value in {{item_singular}}_scores.values():
            print(value)
      - |
        for val in {{item_singular}}_scores.values():
            print(val)
      - |
        for v in {{item_singular}}_scores.values():
            print(v)
      - |
        for score in {{item_singular}}_scores.values():
            print(score)
      - |
        for x in {{item_singular}}_scores.values():
            print(x)
      - |
        for item in {{item_singular}}_scores.values():
            print(item)
      - |
        for num in {{item_singular}}_scores.values():
            print(num)
    hints:
      - .values() returns only the values, not the keys
      - Use when you don't need to know which key each value belongs to
    tags: [dicts, iteration, values]

  - slug: dict-items-fill
    objective: Complete the dict iteration syntax
    title: Dict Items Fill
    difficulty: 1
    concept: collections
    subconcept: dict-iteration
    level: intro
    prereqs: [dicts]
    type: fill-in
    blank_position: 0
    pattern: iteration
    prompt: Fill in the method that returns key-value pairs as tuples.
    template: "for key, value in {{item_singular}}_data.___():"
    expected_answer: "items"
    hints:
      - This method returns tuples of (key, value)
      - Starts with 'i'
    tags: [dicts, items, fill-in]

  - slug: dict-values-fill
    objective: Complete the values iteration
    title: Dict Values Fill
    difficulty: 1
    concept: collections
    subconcept: dict-iteration
    level: intro
    prereqs: [dicts]
    type: fill-in
    blank_position: 0
    pattern: iteration
    prompt: Fill in the method that returns only the values from the dictionary.
    template: "for val in {{item_singular}}_data.___():"
    expected_answer: "values"
    hints:
      - This method ignores the keys entirely
      - Starts with 'v'
    tags: [dicts, values, fill-in]

  - slug: dict-iteration-predict
    objective: Predict what iterating over a dict directly produces
    title: Dict Iteration Output
    difficulty: 2
    concept: collections
    subconcept: dict-iteration
    level: practice
    prereqs: [dict-iteration]
    type: predict
    grading_strategy: execution
    pattern: iteration
    prompt: What does this code print when iterating over the dict?
    code: |
      {{item_singular}}_info = {"{{attr_key_1}}": 100, "{{attr_key_2}}": 200, "status": "active"}
      for item in {{item_singular}}_info:
          print(item)
    expected_answer: |
      {{attr_key_1}}
      {{attr_key_2}}
      status
    hints:
      - Iterating over a dict directly yields its keys, not values
      - Python 3.7+ preserves insertion order
    tags: [dicts, iteration, predict]

  - slug: dict-items-predict
    objective: Predict items() iteration with f-string formatting
    title: Dict Items Output
    difficulty: 2
    concept: collections
    subconcept: dict-iteration
    level: practice
    prereqs: [dict-iteration]
    type: predict
    grading_strategy: execution
    pattern: iteration
    prompt: What does this .items() iteration code print?
    code: |
      {{item_singular}}_data = {"{{attr_key_1}}": 10, "{{attr_key_2}}": 20}
      for key, val in {{item_singular}}_data.items():
          print(f"{key}={val}")
    expected_answer: |
      {{attr_key_1}}=10
      {{attr_key_2}}=20
    hints:
      - .items() yields (key, value) tuples
      - The f-string formats each pair as key=value
    tags: [dicts, items, predict, fstrings]

  - slug: dict-sum-values
    objective: Sum all values in a dictionary
    title: Sum Dict Values
    difficulty: 2
    concept: collections
    subconcept: dict-iteration
    level: practice
    prereqs: [dict-iteration]
    type: write
    pattern: accumulator
    prompt: |
      Write an expression that evaluates to the sum of all values in {{item_singular}}_totals.
      Use the sum() function with .values().
    expected_answer: "sum({{item_singular}}_totals.values())"
    accepted_solutions:
      - "sum({{item_singular}}_totals.values())"
    hints:
      - .values() gives you an iterable of all the values
      - sum() can take any iterable of numbers
    tags: [dicts, values, sum]

  - slug: dict-find-key
    objective: Write a function to find a dictionary key by its value
    title: Find Key by Value
    difficulty: 3
    concept: collections
    subconcept: dict-iteration
    level: edge
    prereqs: [dict-iteration, fn-basics]
    type: write
    pattern: search
    prompt: |
      Write a function called find_key that takes a dict and a target value.
      Return the first key whose value matches target, or None if not found.
    expected_answer: |
      def find_key(d, target):
          for key, value in d.items():
              if value == target:
                  return key
          return None
    accepted_solutions:
      - |
        def find_key(d, target):
            for key, value in d.items():
                if value == target:
                    return key
            return None
      - |
        def find_key(d, target):
            for k, v in d.items():
                if v == target:
                    return k
            return None
      - |
        def find_key(d, target):
            return next((k for k, v in d.items() if v == target), None)
      - |
        def find_key(d, target):
            for key in d:
                if d[key] == target:
                    return key
            return None
    hints:
      - Use .items() to access both keys and values
      - Return immediately when you find a match
      - Return None after the loop if nothing matched
    tags: [dicts, search, functions, edge]

  # --- Integrated Exercises (Multi-Concept) ---
  - slug: list-to-dict-conversion
    objective: Convert a list of key-value tuples into a dictionary
    title: List of Tuples to Dict
    difficulty: 3
    concept: collections
    subconcept: dicts
    level: edge
    prereqs: [lists, tuples, dicts]
    type: write
    pattern: conversion
    prompt: |
      Convert {{list_name}}_pairs (a list of (key, value) tuples) into a dictionary.
      Use the dict() constructor.
    expected_answer: "dict({{list_name}}_pairs)"
    accepted_solutions:
      - "dict({{list_name}}_pairs)"
      - "{k: v for k, v in {{list_name}}_pairs}"
      - "{key: value for key, value in {{list_name}}_pairs}"
    hints:
      - dict() can take an iterable of (key, value) pairs
      - Alternatively, use a dict comprehension with unpacking
    tags: [lists, tuples, dicts, conversion]

  - slug: list-dedup-preserve-order
    objective: Remove duplicates from a list while preserving original order
    title: Deduplicate List (Order-Preserving)
    difficulty: 3
    concept: collections
    subconcept: lists
    level: edge
    prereqs: [lists, sets, dicts]
    type: write
    pattern: transformation
    prompt: |
      Remove duplicates from {{list_name}} while keeping the original order.
      Use dict.fromkeys() which preserves insertion order.
    expected_answer: "list(dict.fromkeys({{list_name}}))"
    accepted_solutions:
      - "list(dict.fromkeys({{list_name}}))"
      - "list(dict.fromkeys({{list_name}}).keys())"
    hints:
      - "dict.fromkeys() creates a dict with items as keys (preserves order in Python 3.7+)"
      - "Converting back to list gives you unique items in original order"
    tags: [lists, sets, dicts, deduplication]

  - slug: dict-from-parallel-lists
    objective: Create a dictionary by zipping two parallel lists together
    title: Dict from Two Lists
    difficulty: 3
    concept: collections
    subconcept: dicts
    level: edge
    prereqs: [lists, dicts, unpacking]
    type: write
    pattern: construction
    prompt: |
      Create a dictionary from {{item_singular}}_keys and {{item_singular}}_values lists.
      Use zip() to pair them up and dict() to create the dictionary.
    expected_answer: "dict(zip({{item_singular}}_keys, {{item_singular}}_values))"
    accepted_solutions:
      - "dict(zip({{item_singular}}_keys, {{item_singular}}_values))"
      - "{k: v for k, v in zip({{item_singular}}_keys, {{item_singular}}_values)}"
    hints:
      - zip() pairs corresponding elements from each list
      - dict() accepts an iterable of (key, value) tuples
    tags: [lists, dicts, zip, construction]

  - slug: sort-dict-by-value
    objective: Sort dictionary items by their values in descending order
    title: Sort Dict by Value
    difficulty: 3
    concept: collections
    subconcept: dict-iteration
    level: edge
    prereqs: [dicts, tuples, dict-iteration]
    type: write
    pattern: transformation
    prompt: |
      Sort {{item_singular}}_scores dict by values (highest first).
      Use sorted() with a key function that extracts the value from each item.
      Return a list of (key, value) tuples.
    expected_answer: "sorted({{item_singular}}_scores.items(), key=lambda x: x[1], reverse=True)"
    accepted_solutions:
      - "sorted({{item_singular}}_scores.items(), key=lambda x: x[1], reverse=True)"
      - "sorted({{item_singular}}_scores.items(), key=lambda item: item[1], reverse=True)"
      - "sorted({{item_singular}}_scores.items(), key=lambda kv: kv[1], reverse=True)"
    hints:
      - ".items() returns (key, value) tuples"
      - "Use lambda x: x[1] to sort by the value (second element)"
      - "reverse=True for descending order"
    tags: [dicts, sorting, lambda, tuples]

  - slug: filter-list-of-dicts
    objective: Filter a list of dictionaries by a condition on dict values
    title: Filter List of Dicts
    difficulty: 3
    concept: collections
    subconcept: lists
    level: edge
    prereqs: [lists, dicts, list-comp]
    type: write
    pattern: filtering
    prompt: |
      Filter {{list_name}} (a list of dicts) to keep only items where "{{status_var}}" key is True.
      Use a list comprehension.
    expected_answer: '[{{item_singular}} for {{item_singular}} in {{list_name}} if {{item_singular}}["{{status_var}}"]]'
    accepted_solutions:
      - '[{{item_singular}} for {{item_singular}} in {{list_name}} if {{item_singular}}["{{status_var}}"]]'
      - "[{{item_singular}} for {{item_singular}} in {{list_name}} if {{item_singular}}['{{status_var}}']]"
      - '[item for item in {{list_name}} if item["{{status_var}}"]]'
      - "[item for item in {{list_name}} if item['{{status_var}}']]"
      - '[{{item_singular}} for {{item_singular}} in {{list_name}} if {{item_singular}}.get("{{status_var}}")]'
      - "[{{item_singular}} for {{item_singular}} in {{list_name}} if {{item_singular}}.get('{{status_var}}')]"
    hints:
      - Use a list comprehension with an if clause
      - Access the dict value with ["key"] syntax
      - The boolean value can be checked directly without == True
    tags: [lists, dicts, comprehensions, filtering]

  # --- Debug Exercises (Pitfall Subconcepts) ---