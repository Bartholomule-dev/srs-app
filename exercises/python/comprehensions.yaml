# exercises/python/comprehensions.yaml
language: python
category: comprehensions

exercises:
  - slug: list-comp-basic
    objective: "Write a basic list comprehension to transform a range into squares"
    title: List Comprehension Basic
    difficulty: 2
    prompt: Create a list of squares from 1 to 5 using a list comprehension
    expected_answer: "[x**2 for x in range(1, 6)]"
    accepted_solutions:
      - "[x**2 for x in range(1, 6)]"
      - "[n**2 for n in range(1, 6)]"
      - "[i**2 for i in range(1, 6)]"
      - "[num**2 for num in range(1, 6)]"
      - "[x*x for x in range(1, 6)]"
      - "[n*n for n in range(1, 6)]"
    hints:
      - "Use [expression for item in iterable] syntax"
      - range(1, 6) gives numbers 1 through 5
    tags: [comprehensions, lists, intermediate]
    concept: comprehensions
    subconcept: list-comp
    level: intro
    prereqs: [for, iteration, lists]
    type: write
    pattern: mapping

  - slug: list-comp-conditional
    objective: "Create a list comprehension with a filter condition"
    title: List Comprehension Conditional
    difficulty: 2
    prompt: Create a list of even {{item_singular}}_id values from 1-10 using a list comprehension
    expected_answer: "[{{item_singular}}_id for {{item_singular}}_id in range(1, 11) if {{item_singular}}_id % 2 == 0]"
    accepted_solutions:
      - "[{{item_singular}}_id for {{item_singular}}_id in range(1, 11) if {{item_singular}}_id % 2 == 0]"
      - "[x for x in range(1, 11) if x % 2 == 0]"
      - "[n for n in range(1, 11) if n % 2 == 0]"
      - "[i for i in range(1, 11) if i % 2 == 0]"
    hints:
      - Add 'if condition' after the for clause
      - Even numbers have remainder 0 when divided by 2
    tags: [comprehensions, conditionals, intermediate]
    concept: comprehensions
    subconcept: list-comp
    level: practice
    prereqs: [for, iteration, lists, conditionals]
    type: write
    pattern: filtering

  # --- Dict Comprehension Intro ---
  - slug: dict-comp-intro
    objective: Create a dictionary using comprehension syntax
    title: Basic Dict Comprehension
    difficulty: 2
    concept: comprehensions
    subconcept: dict-comp
    level: intro
    prereqs: [comprehensions.list-comp]
    type: write
    pattern: mapping
    prompt: Create a dict mapping {{item_singular}}_id values 1-3 to their squares using a dict comprehension
    expected_answer: "{{{item_singular}}_id: {{item_singular}}_id**2 for {{item_singular}}_id in range(1, 4)}"
    accepted_solutions:
      - "{{{item_singular}}_id: {{item_singular}}_id**2 for {{item_singular}}_id in range(1, 4)}"
      - "{{{item_singular}}_id: {{item_singular}}_id*{{item_singular}}_id for {{item_singular}}_id in range(1, 4)}"
      - "{i: i**2 for i in range(1, 4)}"
      - "{n: n**2 for n in range(1, 4)}"
      - "{x: x**2 for x in range(1, 4)}"
    hints:
      - "Dict comprehension uses {key: value for ...}"
      - "range(1, 4) gives 1, 2, 3"
    tags: [comprehensions, dict, intro]

  - slug: dict-comp-predict-intro
    objective: Predict the output of a simple dict comprehension
    title: Dict Comprehension Output
    difficulty: 2
    concept: comprehensions
    subconcept: dict-comp
    level: intro
    prereqs: [comprehensions.list-comp]
    type: predict
    pattern: mapping
    prompt: What does this dict comprehension create?
    code: "{{{item_singular}}_id: {{item_singular}}_id*2 for {{item_singular}}_id in [1, 2, 3]}"
    expected_answer: "{1: 2, 2: 4, 3: 6}"
    accepted_solutions:
      - "{1: 2, 2: 4, 3: 6}"
      - "{1:2, 2:4, 3:6}"
      - "{1: 2,2: 4,3: 6}"
      - "{1:2,2:4,3:6}"
    hints:
      - "Each {{item_singular}}_id becomes a key"
      - "{{item_singular}}_id*2 becomes its value"
    tags: [comprehensions, dict, intro, predict]

  - slug: dict-comp-basic
    objective: "Write a dictionary comprehension with a filter condition"
    title: Filtered Dict Comprehension
    difficulty: 3
    prompt: Create a dict mapping {{item_singular}}_id (1-5) to their squares, but only for even {{item_plural}}
    expected_answer: "{{{item_singular}}_id: {{item_singular}}_id**2 for {{item_singular}}_id in range(1, 6) if {{item_singular}}_id % 2 == 0}"
    accepted_solutions:
      - "{{{item_singular}}_id: {{item_singular}}_id**2 for {{item_singular}}_id in range(1, 6) if {{item_singular}}_id % 2 == 0}"
      - "{x: x**2 for x in range(1, 6) if x % 2 == 0}"
      - "{i: i**2 for i in range(1, 6) if i % 2 == 0}"
    hints:
      - "Use {key: value for {{item_singular}} in iterable if condition}"
      - Even numbers have remainder 0 when divided by 2
    tags: [comprehensions, dicts, filter, advanced]
    concept: comprehensions
    subconcept: dict-comp
    level: practice
    prereqs: [comprehensions.dict-comp]
    type: write
    pattern: filtering

  # --- Set Comprehension Intro ---
  - slug: set-comp-intro
    objective: Create a set using comprehension syntax
    title: Basic Set Comprehension
    difficulty: 2
    concept: comprehensions
    subconcept: set-comp
    level: intro
    prereqs: [comprehensions.list-comp]
    type: write
    pattern: mapping
    prompt: Create a set of squares for 1-4 using a set comprehension
    expected_answer: "{x**2 for x in range(1, 5)}"
    accepted_solutions:
      - "{x**2 for x in range(1, 5)}"
      - "{i**2 for i in range(1, 5)}"
      - "{n**2 for n in range(1, 5)}"
      - "{x*x for x in range(1, 5)}"
      - "{n*n for n in range(1, 5)}"
    hints:
      - "Set comprehension uses {expr for ...} (no colon)"
      - "Duplicates are automatically removed"
    tags: [comprehensions, set, intro]

  - slug: set-comp-predict-intro
    objective: Predict the output of a set comprehension with duplicates
    title: Set Comprehension Deduplication
    difficulty: 2
    concept: comprehensions
    subconcept: set-comp
    level: intro
    prereqs: [comprehensions.set-comp]
    type: predict
    pattern: mapping
    prompt: What values are in this set? (order doesn't matter)
    code: "{{{item_singular}}_id % 3 for {{item_singular}}_id in [1, 2, 3, 4, 5, 6]}"
    expected_answer: "{0, 1, 2}"
    accepted_solutions:
      - "{0, 1, 2}"
      - "{0, 2, 1}"
      - "{1, 0, 2}"
      - "{1, 2, 0}"
      - "{2, 0, 1}"
      - "{2, 1, 0}"
      - "0, 1, 2"
      - "1, 2, 0"
      - "0, 2, 1"
    hints:
      - "Sets are unordered - any order is valid"
      - "Sets remove duplicates: 1%3=1, 2%3=2, 3%3=0, 4%3=1..."
    tags: [comprehensions, set, intro, predict]

  - slug: set-comp-basic
    objective: "Use set comprehension to create a collection of unique values"
    title: Set Comprehension
    difficulty: 3
    prompt: Create a set of first letters from list {{list_name}}
    expected_answer: "{{{item_singular}}[0] for {{item_singular}} in {{list_name}}}"
    accepted_solutions:
      - "{{{item_singular}}[0] for {{item_singular}} in {{list_name}}}"
      - "{x[0] for x in {{list_name}}}"
      - "{item[0] for item in {{list_name}}}"
      - "{s[0] for s in {{list_name}}}"
    hints:
      - Use curly braces like dict but without colon
      - "{{item_singular}}[0] gets the first character of each {{item_singular}}"
    tags: [comprehensions, sets, advanced]
    concept: comprehensions
    subconcept: set-comp
    level: practice
    prereqs: [for, sets, strings, list-comp]
    type: write
    pattern: mapping

  - slug: nested-comp
    objective: "Apply nested loops in a list comprehension to flatten a matrix"
    title: Nested Comprehension
    difficulty: 3
    prompt: Flatten a 2D list called {{list_name}}_grid using comprehension
    expected_answer: "[{{item_singular}} for row in {{list_name}}_grid for {{item_singular}} in row]"
    accepted_solutions:
      - "[{{item_singular}} for row in {{list_name}}_grid for {{item_singular}} in row]"
      - "[x for row in {{list_name}}_grid for x in row]"
      - "[item for row in {{list_name}}_grid for item in row]"
    hints:
      - Use multiple for clauses
      - Outer loop comes first
    tags: [comprehensions, nested, advanced]
    concept: comprehensions
    subconcept: list-comp
    level: edge
    prereqs: [for, lists, list-comp]
    type: write
    pattern: mapping

  # --- Generator Expression Subconcept ---
  - slug: generator-exp-basic
    objective: "Write a generator expression for memory-efficient iteration"
    title: Generator Expression Basic
    difficulty: 2
    concept: comprehensions
    subconcept: generator-exp
    level: intro
    prereqs: [comprehensions.list-comp]
    type: write
    pattern: mapping
    prompt: Write a generator expression that yields squares of 1 to 5
    expected_answer: "(x**2 for x in range(1, 6))"
    accepted_solutions:
      - "(x**2 for x in range(1, 6))"
      - "(n**2 for n in range(1, 6))"
      - "(i**2 for i in range(1, 6))"
      - "(x*x for x in range(1, 6))"
      - "(n*n for n in range(1, 6))"
    hints:
      - Use parentheses instead of brackets
      - Creates iterator, not list - more memory efficient
    tags: [comprehensions, generator, memory]

  - slug: generator-exp-intro
    objective: Use a generator expression inside a function call
    title: Generator in Function
    difficulty: 2
    concept: comprehensions
    subconcept: generator-exp
    level: intro
    prereqs: [comprehensions.list-comp]
    type: write
    pattern: aggregation
    prompt: Use max() with a generator expression to find the largest square from 1 to 5
    expected_answer: "max(x**2 for x in range(1, 6))"
    accepted_solutions:
      - "max(x**2 for x in range(1, 6))"
      - "max(n**2 for n in range(1, 6))"
      - "max(i**2 for i in range(1, 6))"
      - "max(x*x for x in range(1, 6))"
      - "max(n*n for n in range(1, 6))"
    hints:
      - No extra parentheses needed when generator is only argument
      - max() accepts any iterable including generators
    tags: [comprehensions, generator, intro]

  - slug: generator-exp-sum
    objective: "Use a generator expression with an aggregate function"
    title: Sum with Generator
    difficulty: 2
    concept: comprehensions
    subconcept: generator-exp
    level: practice
    prereqs: [comprehensions.generator-exp]
    type: write
    pattern: aggregation
    prompt: Use sum() with a generator expression to compute the sum of squares from 1 to 100
    expected_answer: "sum(x**2 for x in range(1, 101))"
    accepted_solutions:
      - "sum(x**2 for x in range(1, 101))"
      - "sum(n**2 for n in range(1, 101))"
      - "sum(i**2 for i in range(1, 101))"
      - "sum(x*x for x in range(1, 101))"
      - "sum(n*n for n in range(1, 101))"
    hints:
      - No extra parentheses needed inside sum()
      - More memory efficient than sum([...]) with list
    tags: [comprehensions, generator, sum]

  # --- Additional List Comp ---
  - slug: list-comp-ternary
    objective: "Apply a ternary expression inside a list comprehension"
    title: List Comp with Ternary
    difficulty: 3
    concept: comprehensions
    subconcept: list-comp
    level: edge
    prereqs: [comprehensions.list-comp]
    type: write
    pattern: transformation
    prompt: Replace negative values with 0 in {{list_name}} using a list comprehension
    expected_answer: "[{{item_singular}} if {{item_singular}} >= 0 else 0 for {{item_singular}} in {{list_name}}]"
    accepted_solutions:
      - "[{{item_singular}} if {{item_singular}} >= 0 else 0 for {{item_singular}} in {{list_name}}]"
      - "[x if x >= 0 else 0 for x in {{list_name}}]"
      - "[n if n >= 0 else 0 for n in {{list_name}}]"
      - "[0 if x < 0 else x for x in {{list_name}}]"
      - "[0 if n < 0 else n for n in {{list_name}}]"
      - "[max(0, x) for x in {{list_name}}]"
      - "[max(0, n) for n in {{list_name}}]"
    hints:
      - "Use ternary: value_if_true if condition else value_if_false"
      - Or use max(0, x) for a clever alternative
    tags: [comprehensions, ternary, transformation]

  # --- Dict Comp Additional ---
  - slug: dict-comp-zip
    objective: "Create a dictionary comprehension using zip with two lists"
    title: Dict from Two Lists
    difficulty: 2
    concept: comprehensions
    subconcept: dict-comp
    level: practice
    prereqs: [comprehensions.dict-comp]
    type: write
    pattern: construction
    prompt: Create a dict mapping entries from {{list_name}} to corresponding entries in {{attr_key_1}}_values using zip() and a dict comprehension
    expected_answer: "{k: v for k, v in zip({{list_name}}, {{attr_key_1}}_values)}"
    accepted_solutions:
      - "{k: v for k, v in zip({{list_name}}, {{attr_key_1}}_values)}"
      - "{key: val for key, val in zip({{list_name}}, {{attr_key_1}}_values)}"
      - "{x: y for x, y in zip({{list_name}}, {{attr_key_1}}_values)}"
      - "{a: b for a, b in zip({{list_name}}, {{attr_key_1}}_values)}"
    hints:
      - Use zip() to pair corresponding elements
      - Unpack each pair into k, v in the for clause
    tags: [comprehensions, dict, zip]

  # --- Fill-in Exercises ---
  - slug: list-comp-for-fill
    objective: Complete list comprehension for clause
    title: List Comp For Fill-in
    difficulty: 2
    concept: comprehensions
    subconcept: list-comp
    level: intro
    prereqs: [for]
    type: fill-in
    blank_position: 0
    pattern: mapping
    prompt: Fill in the keyword that starts the iteration over {{item_plural}}
    template: "[{{item_singular}}_count * 2 ___ {{item_singular}}_count in range(5)]"
    expected_answer: "for"
    hints:
      - Same keyword used in regular loops
      - Connects expression to iterable
    tags: [comprehensions, list-comp, fill-in]

  - slug: list-comp-if-fill
    objective: Complete list comprehension condition
    title: List Comp If Fill-in
    difficulty: 2
    concept: comprehensions
    subconcept: list-comp
    level: practice
    prereqs: [comprehensions.list-comp]
    type: fill-in
    blank_position: 0
    pattern: filtering
    prompt: Fill in the keyword that adds a filter condition to keep only valid {{item_plural}}
    template: "[{{item_singular}} for {{item_singular}} in {{list_name}} ___ {{item_singular}}.is_valid]"
    expected_answer: "if"
    hints:
      - Keyword for filtering in comprehension
      - Only includes elements where condition is True
    tags: [comprehensions, list-comp, fill-in]

  - slug: dict-comp-colon-fill
    objective: Complete dict comprehension syntax
    title: Dict Comp Syntax Fill-in
    difficulty: 2
    concept: comprehensions
    subconcept: dict-comp
    level: practice
    prereqs: [comprehensions.list-comp]
    type: fill-in
    blank_position: 0
    pattern: mapping
    prompt: Fill in the separator between {{item_singular}}_id and {{item_singular}}_count
    template: "{{{item_singular}}_id ___ {{item_singular}}_id**2 for {{item_singular}}_id in range(3)}"
    expected_answer: ":"
    hints:
      - Separator between key and value in dicts
      - Same as regular dict literal syntax
    tags: [comprehensions, dict-comp, fill-in]

  - slug: set-comp-brace-fill
    objective: Identify set comprehension syntax
    title: Set Comp Syntax Fill-in
    difficulty: 2
    concept: comprehensions
    subconcept: set-comp
    level: practice
    prereqs: [comprehensions.list-comp]
    type: fill-in
    blank_position: 0
    pattern: mapping
    prompt: Fill in the opening brace for a {{item_singular}} set comprehension
    template: "___{{item_singular}}_id for {{item_singular}}_id in [1, 1, 2, 2, 3]}"
    expected_answer: "{"
    hints:
      - Same as dict but without colon
      - Creates unique {{item_plural}}
    tags: [comprehensions, set-comp, fill-in]

  # --- Predict Exercises ---
  - slug: list-comp-predict
    objective: Predict list comprehension output
    title: List Comp Predict
    difficulty: 2
    concept: comprehensions
    subconcept: list-comp
    level: intro
    prereqs: [comprehensions.list-comp]
    type: predict
    pattern: mapping
    generator: comp-mapping
    prompt: What list gets printed?
    code: |
      {{list_name}} = [x * {{m}} for x in range({{n}})]
      print({{list_name}})
    expected_answer: "{{result}}"
    hints:
      - Multiplies each number by {{m}}
      - range({{n}}) gives 0 through {{n}}-1
    tags: [comprehensions, list-comp, predict, dynamic]

  - slug: list-comp-filter-predict
    objective: Predict filtered list comprehension
    title: Filtered List Comp Predict
    difficulty: 2
    concept: comprehensions
    subconcept: list-comp
    level: practice
    prereqs: [comprehensions.list-comp]
    type: predict
    pattern: filtering
    generator: comp-filter
    prompt: What list gets printed?
    code: |
      {{list_name}} = [x for x in range({{n}}) if x % {{mod}} == 0]
      print({{list_name}})
    expected_answer: "{{result}}"
    hints:
      - Only includes numbers divisible by {{mod}}
      - Check x % {{mod}} == 0 for each number
    tags: [comprehensions, list-comp, predict, dynamic]

  - slug: dict-comp-predict
    objective: Predict dict comprehension output
    title: Dict Comp Predict
    difficulty: 2
    concept: comprehensions
    subconcept: dict-comp
    level: practice
    prereqs: [comprehensions.dict-comp]
    type: predict
    pattern: mapping
    prompt: What dictionary gets printed?
    code: |
      {{item_singular}}_squares = {{{item_singular}}_id: {{item_singular}}_id**2 for {{item_singular}}_id in range(3)}
      print({{item_singular}}_squares)
    expected_answer: "{0: 0, 1: 1, 2: 4}"
    accepted_solutions:
      - "{0: 0, 1: 1, 2: 4}"
      - "{0:0, 1:1, 2:4}"
      - "{0: 0,1: 1,2: 4}"
      - "{0:0,1:1,2:4}"
    hints:
      - Maps each key to its square
      - Keys are 0, 1, 2 and values are 0, 1, 4
    tags: [comprehensions, dict-comp, predict]

  - slug: nested-comp-predict
    objective: Predict nested comprehension output
    title: Nested Comp Predict
    difficulty: 3
    concept: comprehensions
    subconcept: list-comp
    level: edge
    prereqs: [comprehensions.list-comp]
    type: predict
    pattern: mapping
    prompt: What list gets printed?
    code: |
      {{list_name}}_grid = [[1, 2], [3, 4]]
      {{item_singular}}_values = [{{item_singular}} for row in {{list_name}}_grid for {{item_singular}} in row]
      print({{item_singular}}_values)
    expected_answer: "[1, 2, 3, 4]"
    accepted_solutions:
      - "[1, 2, 3, 4]"
      - "[1,2,3,4]"
      - "[1, 2, 3, 4]"
    hints:
      - Flattens the 2D grid into a 1D list
      - Outer loop iterates rows, inner loop iterates elements
    tags: [comprehensions, nested, predict]

  # --- Dynamic Dict Comprehension Exercises ---
  - slug: dict-comp-dynamic
    objective: Predict dictionary comprehension output
    title: Dynamic Dict Comp
    difficulty: 2
    concept: comprehensions
    subconcept: dict-comp
    level: practice
    prereqs: [comprehensions.dict-comp]
    type: predict
    pattern: mapping
    generator: dict-comp
    prompt: "What dictionary does this dict comprehension produce?"
    code: |
      mapping = {{code}}
      print(mapping)
    expected_answer: "{{result}}"
    hints:
      - "This comprehension {{description}}"
      - "Dict comprehensions use {key: value for ...} syntax"
    tags: [comprehensions, dict-comp, predict, dynamic]

  - slug: dict-comp-write-dynamic
    objective: Write a dictionary comprehension
    title: Dynamic Dict Comp Write
    difficulty: 2
    concept: comprehensions
    subconcept: dict-comp
    level: practice
    prereqs: [comprehensions.dict-comp]
    type: write
    pattern: mapping
    generator: dict-comp
    prompt: "Write a dict comprehension that {{description}} for range({{n}})"
    expected_answer: "{{code}}"
    hints:
      - "Use {key: value for x in range({{n}})}"
      - "The colon separates key from value"
    tags: [comprehensions, dict-comp, write, dynamic]

  # --- List Transform Exercises (using list-transform generator) ---
  - slug: list-comp-transform-dynamic
    objective: Predict the output of a list transformation comprehension
    title: Dynamic List Transform
    difficulty: 2
    concept: comprehensions
    subconcept: list-comp
    level: practice
    prereqs: [comprehensions.list-comp]
    type: predict
    pattern: mapping
    generator: list-transform
    prompt: "What does this code print for the {{list_name}}?"
    code: "{{code}}"
    expected_answer: "{{outputStr}}"
    hints:
      - "This comprehension will {{description}}"
      - "Start with the input {{inputStr}}"
    tags: [comprehensions, list-comp, transform, dynamic]
    target_construct:
      type: comprehension
      feedback: "List comprehensions are a concise way to transform {{item_plural}}"

  - slug: list-comp-filter-dynamic
    objective: Predict the output of a filtering list comprehension
    title: Dynamic List Filter
    difficulty: 2
    concept: comprehensions
    subconcept: list-comp
    level: practice
    prereqs: [comprehensions.list-comp]
    type: predict
    pattern: filtering
    generator: list-transform
    prompt: "What does this code print when filtering the {{list_name}}?"
    code: "{{code}}"
    expected_answer: "{{outputStr}}"
    hints:
      - "The filter will {{description}}"
      - "Check which {{item_plural}} pass the condition"
    tags: [comprehensions, list-comp, filter, dynamic]
    target_construct:
      type: comprehension
      feedback: "Use list comprehensions with if clauses to filter {{item_plural}}"

  - slug: list-comp-write-transform-dynamic
    objective: Write a list comprehension to transform values
    title: Dynamic List Comp Write
    difficulty: 2
    concept: comprehensions
    subconcept: list-comp
    level: practice
    prereqs: [comprehensions.list-comp]
    type: write
    pattern: mapping
    generator: list-transform
    prompt: "Write a list comprehension to {{description}} from {{list_name}} = {{inputStr}}"
    expected_answer: "{{expression}}"
    hints:
      - "Use [expression for {{item_singular}} in {{list_name}}] syntax"
      - "The expression should {{description}}"
    tags: [comprehensions, list-comp, write, dynamic]
    target_construct:
      type: comprehension
      feedback: "List comprehensions are more Pythonic than explicit loops"
  - slug: active-users-integrated
    objective: Filter and format user data combining enumerate, list comp, and set membership
    title: Active Users with Index
    difficulty: 3
    concept: comprehensions
    subconcept: list-comp
    level: integrated
    prereqs: [list-comp, iteration, sets]
    targets: [list-comp, iteration, sets, fstrings]
    type: write
    pattern: transformation
    prompt: |
      Given users = ["alice", "bob", "carlos"] and active = {"alice", "carlos"},
      create a list of strings like "0:alice" for active users only using enumerate.
    expected_answer: '[f"{i}:{u}" for i, u in enumerate(users) if u in active]'
    accepted_solutions:
      - '[f"{i}:{u}" for i, u in enumerate(users) if u in active]'
      - "[f'{i}:{u}' for i, u in enumerate(users) if u in active]"
    hints:
      - Use enumerate() for index and value
      - Filter with if condition at end
      - F-string for formatting output
    tags: [comprehension, enumerate, filter, integrated]

  - slug: error-code-extractor-integrated
    objective: Build a log analysis pipeline with generator expression and string parsing
    title: Error Code Extractor
    difficulty: 3
    concept: comprehensions
    subconcept: generator-exp
    level: integrated
    prereqs: [generator-exp, string-methods, conversion]
    targets: [generator-exp, string-methods, conversion, conditionals]
    type: write
    pattern: transformation
    prompt: |
      Given logs = ["ERROR: 500 - Fail", "INFO: OK", "ERROR: 404 - Not found"],
      create a generator expression that yields integer error codes (500, 404)
      only from lines starting with "ERROR:".
    expected_answer: (int(line.split()[1]) for line in logs if line.startswith("ERROR:"))
    accepted_solutions:
      - (int(line.split()[1]) for line in logs if line.startswith("ERROR:"))
      - '(int(line.split()[1]) for line in logs if line.startswith("ERROR:"))'
      - (int(line.split()[1]) for line in logs if line.startswith("ERROR"))
      - '(int(line.split()[1]) for line in logs if line.startswith("ERROR"))'
    hints:
      - Use generator expression syntax (parentheses)
      - split() breaks the line, index [1] gets the code
      - startswith("ERROR:") for filtering
    tags: [generator, string-parsing, logs, integrated]

  # --- Generator Functions (yield) ---
  - slug: generator-countdown
    objective: Create a simple generator function using yield
    title: Countdown Generator
    difficulty: 2
    concept: comprehensions
    subconcept: generators
    level: intro
    prereqs: [generator-exp]
    type: write
    pattern: function
    prompt: |
      Write a generator function `{{item_singular}}_countdown(n)` that yields numbers from n down to 1.

      {{item_singular}}_countdown(3) should yield 3, 2, 1.
    expected_answer: |
      def {{item_singular}}_countdown(n):
          while n > 0:
              yield n
              n -= 1
    accepted_solutions:
      - |
        def {{item_singular}}_countdown(n):
            while n > 0:
                yield n
                n -= 1
      - |
        def {{item_singular}}_countdown(n):
            for i in range(n, 0, -1):
                yield i
    hints:
      - Use yield instead of return
      - yield pauses the function and produces a value
      - The function resumes when next() is called
    tags: [generators, yield, intro]

  - slug: generator-evens
    objective: Create a generator that yields even numbers up to a limit
    title: Even Numbers Generator
    difficulty: 2
    concept: comprehensions
    subconcept: generators
    level: practice
    prereqs: [generators]
    type: write
    pattern: filtering
    prompt: |
      Write a generator function `even_{{list_name}}(n)` that yields even numbers from 2 up to n (inclusive if n is even).

      even_{{list_name}}(6) should yield 2, 4, 6.
    expected_answer: |
      def even_{{list_name}}(n):
          for i in range(2, n + 1, 2):
              yield i
    accepted_solutions:
      - |
        def even_{{list_name}}(n):
            for i in range(2, n + 1, 2):
                yield i
      - |
        def even_{{list_name}}(n):
            i = 2
            while i <= n:
                yield i
                i += 2
    hints:
      - Use range with step of 2
      - Start from 2 (first even positive integer)
      - yield each even number
    tags: [generators, yield, filtering]

  - slug: generator-predict-lazy
    objective: Understand that generators are lazily evaluated
    title: Predict Generator Behavior
    difficulty: 2
    concept: comprehensions
    subconcept: generators
    level: practice
    prereqs: [generators]
    type: predict
    pattern: output
    prompt: "What gets printed? Write each line of output."
    code: |
      def numbers():
          print("Starting")
          yield 1
          print("After 1")
          yield 2
          print("After 2")

      gen = numbers()
      print("Created")
      print(next(gen))
    expected_answer: |
      Created
      Starting
      1
    accepted_solutions:
      - "Created\nStarting\n1"
      - |
        Created
        Starting
        1
      - "Created, Starting, 1"
    hints:
      - Generators are lazy - they don't run until iterated
      - next() runs until the first yield
      - Creating the generator doesn't execute the function body
    tags: [generators, lazy-evaluation, predict]

  - slug: generator-fibonacci
    objective: Create an infinite generator using yield
    title: Fibonacci Generator
    difficulty: 3
    concept: comprehensions
    subconcept: generators
    level: edge
    prereqs: [generators]
    type: write
    pattern: iteration
    prompt: |
      Write an infinite generator function `fibonacci()` that yields the Fibonacci sequence: 0, 1, 1, 2, 3, 5, 8...
    expected_answer: |
      def fibonacci():
          a, b = 0, 1
          while True:
              yield a
              a, b = b, a + b
    accepted_solutions:
      - |
        def fibonacci():
            a, b = 0, 1
            while True:
                yield a
                a, b = b, a + b
      - |
        def fibonacci():
            prev, curr = 0, 1
            while True:
                yield prev
                prev, curr = curr, prev + curr
      - |
        def fibonacci():
            x, y = 0, 1
            while True:
                yield x
                x, y = y, x + y
    hints:
      - Use while True for infinite sequence
      - yield pauses between values
      - Update a, b with tuple unpacking
    tags: [generators, fibonacci, infinite, edge]