# exercises/python/functions.yaml
language: python
category: functions

exercises:
  - slug: define-function
    objective: "Define a basic function using the def keyword"
    title: Define Function
    difficulty: 1
    prompt: Write the function header for `{{action_verb}}_{{item_singular}}` with one parameter named `{{item_singular}}`
    expected_answer: "def {{action_verb}}_{{item_singular}}({{item_singular}}):"
    accepted_solutions:
      - "def {{action_verb}}_{{item_singular}}({{item_singular}}):"
      - "def {{action_verb}}_{{item_singular}}( {{item_singular}} ):"
    hints:
      - Start with the `def` keyword
      - End the line with a colon
    tags: [functions, def, beginner]
    concept: functions
    subconcept: fn-basics
    level: intro
    prereqs: [foundations]
    type: write
    pattern: definition

  - slug: function-return
    objective: "Write a function that returns a value"
    title: Function with Return
    difficulty: 2
    prompt: Define a function get_{{item_singular}} that takes {{id_var}} and returns it
    expected_answer: |
      def get_{{item_singular}}({{id_var}}):
          return {{id_var}}
    accepted_solutions:
      - |
        def get_{{item_singular}}({{id_var}}):
            return {{id_var}}
      - "def get_{{item_singular}}({{id_var}}):\n    return {{id_var}}"
      - "def get_{{item_singular}}({{id_var}}):\n\treturn {{id_var}}"
    hints:
      - Use return to send back a value
      - The body is indented under the def line
    tags: [functions, return, parameters]
    concept: functions
    subconcept: fn-basics
    level: intro
    prereqs: [foundations]
    type: write
    pattern: definition

  # --- Arguments Subconcept Intro ---
  - slug: positional-arg-intro
    objective: Call a function with positional arguments
    title: Positional Arguments
    difficulty: 1
    concept: functions
    subconcept: arguments
    level: intro
    prereqs: [fn-basics]
    type: write
    pattern: invocation
    prompt: Write the call that passes `1` positionally into `get_{{item_singular}}`
    expected_answer: "get_{{item_singular}}(1)"
    accepted_solutions:
      - "get_{{item_singular}}(1)"
      - "get_{{item_singular}}( 1 )"
    hints:
      - Function name followed by parentheses
      - Arguments go inside the parentheses
    tags: [functions, arguments, positional]

  - slug: keyword-arg-intro
    objective: Call a function using keyword argument syntax
    title: Keyword Arguments Intro
    difficulty: 1
    concept: functions
    subconcept: arguments
    level: intro
    prereqs: [fn-basics]
    type: write
    pattern: invocation
    prompt: Write the call using a keyword argument so `{{item_singular}}` receives `"{{item_example}}"`
    expected_answer: '{{action_verb}}_{{item_singular}}({{item_singular}}="{{item_example}}")'
    accepted_solutions:
      - '{{action_verb}}_{{item_singular}}({{item_singular}}="{{item_example}}")'
      - "{{action_verb}}_{{item_singular}}({{item_singular}}='{{item_example}}')"
    hints:
      - Use `name=value` syntax
      - Function is `{{action_verb}}_{{item_singular}}`
    tags: [functions, arguments, keyword]

  - slug: mixed-args-intro
    objective: Combine positional and keyword arguments in a function call
    title: Mixed Arguments
    difficulty: 2
    concept: functions
    subconcept: arguments
    level: intro
    prereqs: [fn-basics]
    type: write
    pattern: invocation
    prompt: Write the call passing `"{{item_example}}"` positionally and `{{status_var}}=True` as a keyword
    expected_answer: 'add_{{item_singular}}("{{item_example}}", {{status_var}}=True)'
    accepted_solutions:
      - 'add_{{item_singular}}("{{item_example}}", {{status_var}}=True)'
      - "add_{{item_singular}}('{{item_example}}', {{status_var}}=True)"
    hints:
      - Positional arguments come first
      - Function is `add_{{item_singular}}`
    tags: [functions, arguments, mixed]

  - slug: kwargs-function
    objective: "Use **kwargs to accept arbitrary configuration settings"
    title: Configuration with Kwargs
    difficulty: 3
    prompt: Write the function header for `configure_{{item_singular}}` that accepts arbitrary keyword settings
    expected_answer: "def configure_{{item_singular}}(**kwargs):"
    accepted_solutions:
      - "def configure_{{item_singular}}(**kwargs):"
      - "def configure_{{item_singular}}(**options):"
      - "def configure_{{item_singular}}(**settings):"
    hints:
      - Use `**kwargs` (double asterisk) for keyword arguments
      - kwargs becomes a dictionary of name=value pairs
    tags: [functions, kwargs, advanced]
    concept: functions
    subconcept: arguments
    level: edge
    prereqs: [foundations, fn-basics, arguments]
    type: write
    pattern: definition

  # --- Additional Basics Subconcept ---
  - slug: function-no-params
    objective: "Define a function with no parameters"
    title: Function No Parameters
    difficulty: 1
    concept: functions
    subconcept: fn-basics
    level: intro
    prereqs: [foundations]
    type: write
    pattern: definition
    prompt: Write the function header for `show_{{list_name}}` with no parameters
    expected_answer: "def show_{{list_name}}():"
    accepted_solutions:
      - "def show_{{list_name}}():"
      - "def show_{{list_name}}( ):"
    hints:
      - Empty parentheses `()` for no parameters
      - Still need the parentheses even with no args
    tags: [functions, definition, beginner]

  - slug: function-call
    objective: "Call a function with an argument"
    title: Call Function
    difficulty: 1
    concept: functions
    subconcept: fn-basics
    level: intro
    prereqs: [fn-basics]
    type: write
    pattern: invocation
    prompt: Write the call passing the string `"{{item_example}}"` into `get_{{item_singular}}`
    expected_answer: 'get_{{item_singular}}("{{item_example}}")'
    accepted_solutions:
      - 'get_{{item_singular}}("{{item_example}}")'
      - "get_{{item_singular}}('{{item_example}}')"
    hints:
      - Function name followed by parentheses
      - Arguments go inside the parentheses
    tags: [functions, call, beginner]

  - slug: function-multiple-return
    objective: "Return multiple values from a function using tuple unpacking"
    title: Return Multiple Values
    difficulty: 2
    concept: functions
    subconcept: fn-basics
    level: practice
    prereqs: [fn-basics]
    type: write
    pattern: definition
    prompt: Write a return statement that returns both `{{attr_key_1}}` and `{{attr_key_2}}` as a tuple
    expected_answer: return {{attr_key_1}}, {{attr_key_2}}
    accepted_solutions:
      - return {{attr_key_1}}, {{attr_key_2}}
      - "return {{attr_key_1}}, {{attr_key_2}}"
      - "return ({{attr_key_1}}, {{attr_key_2}})"
    hints:
      - Comma-separated values become a tuple
      - Caller can unpack with `a, b = func()`
    tags: [functions, return, tuple]

  # --- Additional Arguments Subconcept ---
  - slug: keyword-only-args
    objective: "Define keyword-only parameters using the * separator"
    title: Keyword-Only Arguments
    difficulty: 3
    concept: functions
    subconcept: arguments
    level: edge
    prereqs: [arguments]
    type: write
    pattern: definition
    prompt: Write the function header where `{{status_var}}` is keyword-only
    expected_answer: "def {{action_verb}}_{{item_singular}}({{id_var}}, *, {{status_var}}):"
    accepted_solutions:
      - "def {{action_verb}}_{{item_singular}}({{id_var}}, *, {{status_var}}):"
      - "def {{action_verb}}_{{item_singular}}({{id_var}},*,{{status_var}}):"
    hints:
      - Bare `*` separates positional from keyword-only params
      - Function is `{{action_verb}}_{{item_singular}}` with params `{{id_var}}` and `{{status_var}}`
    tags: [functions, arguments, keyword-only]

  - slug: positional-only-args
    objective: "Define positional-only parameters using the / separator"
    title: Positional-Only Arguments
    difficulty: 3
    concept: functions
    subconcept: arguments
    level: edge
    prereqs: [arguments]
    type: write
    pattern: definition
    prompt: Write the function header where `{{id_var}}` is positional-only (use `/`)
    expected_answer: "def get_{{item_singular}}({{id_var}}, /, {{attr_key_1}}):"
    accepted_solutions:
      - "def get_{{item_singular}}({{id_var}}, /, {{attr_key_1}}):"
      - "def get_{{item_singular}}({{id_var}},/,{{attr_key_1}}):"
    hints:
      - "`/` separates positional-only from other params"
      - Python 3.8+ feature
    tags: [functions, arguments, positional-only]

  # --- Lambda Subconcept ---
  - slug: lambda-simple
    objective: "Write a lambda function for simple expressions"
    title: Simple Lambda
    difficulty: 2
    concept: functions
    subconcept: lambda
    level: intro
    prereqs: [fn-basics]
    type: write
    pattern: definition
    prompt: Write a lambda that takes `{{item_singular}}_count` and returns it doubled
    expected_answer: "lambda {{item_singular}}_count: {{item_singular}}_count * 2"
    accepted_solutions:
      - "lambda {{item_singular}}_count: {{item_singular}}_count * 2"
      - "lambda x: x * 2"
      - "lambda n: n * 2"
      - "lambda val: val * 2"
      - "lambda value: value * 2"
      - "lambda i: i * 2"
      - "lambda num: num * 2"
      - "lambda {{item_singular}}_count: 2 * {{item_singular}}_count"
      - "lambda x: 2 * x"
    hints:
      - "Format is: `lambda args: expression`"
      - No `def` keyword, no `return` keyword needed
    tags: [functions, lambda, beginner]

  - slug: lambda-two-args
    objective: "Create a lambda with multiple parameters"
    title: Lambda Two Arguments
    difficulty: 2
    concept: functions
    subconcept: lambda
    level: practice
    prereqs: [lambda]
    type: write
    pattern: definition
    prompt: Write a lambda that takes two parameters and adds them together
    expected_answer: "lambda {{attr_key_1}}, {{attr_key_2}}: {{attr_key_1}} + {{attr_key_2}}"
    accepted_solutions:
      - "lambda {{attr_key_1}}, {{attr_key_2}}: {{attr_key_1}} + {{attr_key_2}}"
      - "lambda a, b: a + b"
      - "lambda x, y: x + y"
      - "lambda a,b: a+b"
      - "lambda x,y: x+y"
    hints:
      - Multiple args separated by comma before the colon
      - Expression after colon is the return value
    tags: [functions, lambda, arguments]

  - slug: lambda-conditional
    objective: "Use a ternary expression inside a lambda function"
    title: Lambda with Conditional
    difficulty: 3
    concept: functions
    subconcept: lambda
    level: edge
    prereqs: [lambda]
    type: write
    pattern: definition
    prompt: Create a lambda that takes `is_{{status_var}}` and returns `"{{status_var}}"` if true, otherwise `"pending"`
    expected_answer: 'lambda is_{{status_var}}: "{{status_var}}" if is_{{status_var}} else "pending"'
    accepted_solutions:
      - 'lambda is_{{status_var}}: "{{status_var}}" if is_{{status_var}} else "pending"'
      - "lambda is_{{status_var}}: '{{status_var}}' if is_{{status_var}} else 'pending'"
      - 'lambda x: "{{status_var}}" if x else "pending"'
      - "lambda x: '{{status_var}}' if x else 'pending'"
    hints:
      - "Use ternary: `value_if_true if condition else value_if_false`"
      - Boolean variables don't need `== True` comparison
    tags: [functions, lambda, conditional]

  - slug: sorted-key-lambda
    objective: "Apply a lambda as a key function for sorting"
    title: Sorted with Lambda Key
    difficulty: 2
    concept: functions
    subconcept: lambda
    level: edge
    prereqs: [lambda, lists]
    type: write
    pattern: construction
    prompt: Given `{{list_name}}` is a list of 2-item tuples, write an expression that returns it sorted by the second element
    expected_answer: "sorted({{list_name}}, key=lambda x: x[1])"
    accepted_solutions:
      - "sorted({{list_name}}, key=lambda x: x[1])"
      - "sorted({{list_name}}, key=lambda item: item[1])"
      - "sorted({{list_name}}, key=lambda t: t[1])"
      - "sorted({{list_name}}, key=lambda e: e[1])"
    hints:
      - Use `key` parameter with a lambda
      - Lambda extracts the element to sort by
    tags: [functions, lambda, sorting]

  # --- Scope Subconcept ---
  - slug: scope-intro
    objective: Understand that variables defined inside functions are local
    title: Local Scope Basics
    difficulty: 2
    concept: functions
    subconcept: scope
    level: intro
    prereqs: [fn-basics]
    type: predict
    grading_strategy: execution
    pattern: scope
    prompt: What does this print?
    code: |
      x = 10
      def foo():
          x = 20
          print(x)
      foo()
    expected_answer: "20"
    hints:
      - Inside the function, x is local
      - Local x shadows global x
    tags: [functions, scope, intro]

  - slug: scope-global-read
    objective: Understand that functions can read global variables
    title: Reading Global Variables
    difficulty: 2
    concept: functions
    subconcept: scope
    level: intro
    prereqs: [fn-basics]
    type: predict
    grading_strategy: execution
    pattern: scope
    prompt: What does this print?
    code: |
      x = 10
      def foo():
          print(x)
      foo()
    expected_answer: "10"
    hints:
      - No local x, so Python looks in global scope
      - Functions can read globals without declaration
    tags: [functions, scope, intro, global]

  - slug: global-keyword
    objective: "Declare a global variable from within a function"
    title: Global Keyword
    difficulty: 2
    concept: functions
    subconcept: scope
    level: practice
    prereqs: [fn-basics]
    type: write
    pattern: declaration
    prompt: Write the statement to declare `{{item_singular}}_count` as a global variable inside a function body
    expected_answer: global {{item_singular}}_count
    accepted_solutions:
      - global {{item_singular}}_count
      - "global {{item_singular}}_count"
    hints:
      - Use the `global` keyword
      - This tells Python to use the module-level variable
    tags: [functions, scope, global]

  - slug: nonlocal-keyword
    objective: "Access an enclosing function's variable using nonlocal"
    title: Nonlocal Keyword
    difficulty: 3
    concept: functions
    subconcept: scope
    level: edge
    prereqs: [scope]
    type: write
    pattern: declaration
    prompt: Write the statement to access the outer function's `{{item_singular}}_count` from an inner function
    expected_answer: nonlocal {{item_singular}}_count
    accepted_solutions:
      - nonlocal {{item_singular}}_count
      - "nonlocal {{item_singular}}_count"
    hints:
      - Use `nonlocal` for enclosing scope
      - Not `global`, not local
    tags: [functions, scope, nonlocal]

  # --- Type Hints Subconcept ---
  - slug: typehint-param
    objective: "Add type hints to function parameters"
    title: Type Hint Parameter
    difficulty: 2
    concept: functions
    subconcept: typehints
    level: intro
    prereqs: [fn-basics]
    type: write
    pattern: definition
    prompt: Write the function header for `get_{{item_singular}}` with `{{attr_key_1}}` typed as `str`
    expected_answer: "def get_{{item_singular}}({{attr_key_1}}: str):"
    accepted_solutions:
      - "def get_{{item_singular}}({{attr_key_1}}: str):"
      - "def get_{{item_singular}}( {{attr_key_1}}: str ):"
    hints:
      - "Use `: type` after parameter name"
      - Type hints are optional but improve IDE support
    tags: [functions, typehints, annotation]

  - slug: typehint-return
    objective: "Annotate a function's return type"
    title: Type Hint Return
    difficulty: 2
    concept: functions
    subconcept: typehints
    level: intro
    prereqs: [typehints]
    type: write
    pattern: definition
    prompt: Define `count_{{list_name}}` that takes `{{list_name}}` and returns `int`
    expected_answer: "def count_{{list_name}}({{list_name}}) -> int:"
    accepted_solutions:
      - "def count_{{list_name}}({{list_name}}) -> int:"
      - "def count_{{list_name}}({{list_name}}: list) -> int:"
    hints:
      - Use `-> type` before colon for return type
      - Return type annotation comes after parameters
    tags: [functions, typehints, return]

  - slug: typehint-list
    objective: "Use generic type hints for collection parameters"
    title: Type Hint List
    difficulty: 2
    concept: functions
    subconcept: typehints
    level: practice
    prereqs: [typehints]
    type: write
    pattern: definition
    prompt: Write the function header with `{{list_name}}` typed as `list[str]`
    expected_answer: "def process_{{list_name}}({{list_name}}: list[str]):"
    accepted_solutions:
      - "def process_{{list_name}}({{list_name}}: list[str]):"
      - "def process_{{list_name}}({{list_name}}: List[str]):"
    hints:
      - Generic types use `[]` for element type
      - Python 3.9+ allows `list[str]` directly
    tags: [functions, typehints, generic]

  - slug: typehint-optional
    objective: "Define an optional parameter type using union syntax"
    title: Type Hint Optional
    difficulty: 2
    concept: functions
    subconcept: typehints
    level: edge
    prereqs: [typehints]
    type: write
    pattern: definition
    prompt: Write the function header where `{{attr_key_1}}` can be `str` or `None`
    expected_answer: "def find_{{item_singular}}({{attr_key_1}}: str | None):"
    accepted_solutions:
      - "def find_{{item_singular}}({{attr_key_1}}: str | None):"
      - "def find_{{item_singular}}({{attr_key_1}}: Optional[str]):"
      - "def find_{{item_singular}}({{attr_key_1}}: None | str):"
    hints:
      - Use `| None` for optional (Python 3.10+)
      - Or `Optional[type]` from typing
    tags: [functions, typehints, optional]

  - slug: typehint-callable
    objective: "Type hint a function parameter as a Callable"
    title: Type Hint Callable
    difficulty: 3
    concept: functions
    subconcept: typehints
    level: edge
    prereqs: [typehints, lambda]
    type: write
    pattern: definition
    prompt: Write the function header where `func` takes `int` and returns `int`. Assume `Callable` is imported
    expected_answer: "def {{action_verb}}_{{item_singular}}(func: Callable[[int], int]):"
    accepted_solutions:
      - "def {{action_verb}}_{{item_singular}}(func: Callable[[int], int]):"
      - "def {{action_verb}}_{{item_singular}}(func: Callable[[int], int]) -> int:"
    hints:
      - "Callable[[args], return] format"
      - Function name is `{{action_verb}}_{{item_singular}}`
    tags: [functions, typehints, callable]

  # --- Defaults Subconcept ---
  - slug: default-param-intro
    objective: Define a function parameter with an integer default value
    title: Default Parameter Intro
    difficulty: 1
    concept: functions
    subconcept: defaults
    level: intro
    prereqs: [fn-basics]
    type: write
    pattern: definition
    prompt: Write the function header for `get_{{item_singular}}` where `{{id_var}}` defaults to `1`
    expected_answer: "def get_{{item_singular}}({{id_var}}=1):"
    accepted_solutions:
      - "def get_{{item_singular}}({{id_var}}=1):"
      - "def get_{{item_singular}}({{id_var}} = 1):"
    hints:
      - Use `=` to set the default value
      - Default goes after the parameter name
    tags: [functions, defaults, intro]

  - slug: default-param-simple
    objective: "Define a function with a single default parameter value"
    title: Default Parameter Simple
    difficulty: 1
    concept: functions
    subconcept: defaults
    level: intro
    prereqs: [fn-basics]
    type: write
    pattern: definition
    prompt: Write the function header where `{{status_var}}` defaults to `False`
    expected_answer: "def add_{{item_singular}}({{item_singular}}, {{status_var}}=False):"
    accepted_solutions:
      - "def add_{{item_singular}}({{item_singular}}, {{status_var}}=False):"
      - "def add_{{item_singular}}({{item_singular}}, {{status_var}} = False):"
    hints:
      - Default values use `=`
      - Function is `add_{{item_singular}}` with params `{{item_singular}}`, `{{status_var}}`
    tags: [functions, defaults]

  - slug: default-param-multiple
    objective: "Define a function with multiple default parameter values"
    title: Multiple Default Parameters
    difficulty: 2
    concept: functions
    subconcept: defaults
    level: practice
    prereqs: [defaults]
    type: write
    pattern: definition
    prompt: Write the function header with defaults `{{attr_key_2}}="medium"` and `{{status_var}}=False`
    expected_answer: 'def create_{{item_singular}}({{attr_key_1}}, {{attr_key_2}}="medium", {{status_var}}=False):'
    accepted_solutions:
      - 'def create_{{item_singular}}({{attr_key_1}}, {{attr_key_2}}="medium", {{status_var}}=False):'
      - "def create_{{item_singular}}({{attr_key_1}}, {{attr_key_2}}='medium', {{status_var}}=False):"
    hints:
      - Multiple defaults follow same pattern
      - Function is `create_{{item_singular}}` with required param `{{attr_key_1}}`
    tags: [functions, defaults]

  - slug: default-param-none
    objective: "Use None as a default parameter to avoid mutable default issues"
    title: Default Parameter None
    difficulty: 2
    concept: functions
    subconcept: defaults
    level: practice
    prereqs: [defaults]
    type: write
    pattern: definition
    prompt: Write the function header using `None` as the default for `{{list_name}}` (to avoid mutable defaults)
    expected_answer: "def add_{{item_singular}}({{item_singular}}, {{list_name}}=None):"
    accepted_solutions:
      - "def add_{{item_singular}}({{item_singular}}, {{list_name}}=None):"
      - "def add_{{item_singular}}({{item_singular}}, {{list_name}} = None):"
    hints:
      - None is safe default for mutables
      - Check for None inside function and create list there
    tags: [functions, defaults, mutable]

  - slug: default-param-mutable-trap
    objective: "Recognize the mutable default argument anti-pattern"
    title: Mutable Default Trap
    difficulty: 3
    concept: functions
    subconcept: defaults
    level: edge
    prereqs: [defaults]
    type: write
    pattern: definition
    prompt: Write the function header for `add_item` using `None` as the default for `items` (not `[]`)
    expected_answer: "def add_item(item, items=None):"
    accepted_solutions:
      - "def add_item(item, items=None):"
      - "def add_item(item, items = None):"
    hints:
      - Never use `[]` as default - it's shared across calls
      - Use `None` then create list inside function
    tags: [functions, defaults, mutable, anti-pattern]

  # --- Args-Kwargs Subconcept ---
  - slug: args-intro
    objective: "Define a function that accepts variable positional arguments with *args"
    title: Variable Args Intro
    difficulty: 2
    concept: functions
    subconcept: args-kwargs
    level: intro
    prereqs: [fn-basics]
    type: write
    pattern: definition
    prompt: Write the function header for `combine_{{list_name}}` that accepts any number of positional arguments
    expected_answer: "def combine_{{list_name}}(*args):"
    accepted_solutions:
      - "def combine_{{list_name}}(*args):"
      - "def combine_{{list_name}}(*items):"
      - "def combine_{{list_name}}(*values):"
    hints:
      - "Use `*` before parameter name"
      - args is a tuple inside function
    tags: [functions, args-kwargs, args]

  - slug: kwargs-intro
    objective: "Define a function that accepts variable keyword arguments with **kwargs"
    title: Variable Kwargs Intro
    difficulty: 2
    concept: functions
    subconcept: args-kwargs
    level: intro
    prereqs: [fn-basics]
    type: write
    pattern: definition
    prompt: Write the function header for `build_{{item_singular}}` that accepts any keyword arguments
    expected_answer: "def build_{{item_singular}}(**kwargs):"
    accepted_solutions:
      - "def build_{{item_singular}}(**kwargs):"
      - "def build_{{item_singular}}(**options):"
    hints:
      - "Use `**` before parameter name"
      - kwargs is a dict inside function
    tags: [functions, args-kwargs, kwargs]

  - slug: args-kwargs-combined
    objective: "Combine *args and **kwargs in a single function definition"
    title: Combined Args and Kwargs
    difficulty: 3
    concept: functions
    subconcept: args-kwargs
    level: practice
    prereqs: [args-kwargs]
    type: write
    pattern: definition
    prompt: Write the function header for `{{action_verb}}_{{item_singular}}` that accepts any positional and keyword arguments
    expected_answer: "def {{action_verb}}_{{item_singular}}(*args, **kwargs):"
    accepted_solutions:
      - "def {{action_verb}}_{{item_singular}}(*args, **kwargs):"
      - "def {{action_verb}}_{{item_singular}}(*args,**kwargs):"
    hints:
      - "*args comes before **kwargs"
      - "Order matters: *args, **kwargs"
    tags: [functions, args-kwargs, combined]

  - slug: args-kwargs-forward
    objective: "Forward all arguments to another function using *args and **kwargs"
    title: Forward All Arguments
    difficulty: 3
    concept: functions
    subconcept: args-kwargs
    level: edge
    prereqs: [args-kwargs]
    type: write
    pattern: invocation
    prompt: Inside `wrapper(*args, **kwargs)`, write the call that forwards all arguments to `inner_func`
    expected_answer: "inner_func(*args, **kwargs)"
    accepted_solutions:
      - "inner_func(*args, **kwargs)"
      - "inner_func(*args,**kwargs)"
    hints:
      - Unpack with `*` and `**` when calling
      - Same syntax for collecting and spreading
    tags: [functions, args-kwargs, forwarding]

  # --- Fill-in Exercises ---
  - slug: def-keyword-fill
    objective: Complete the function definition keyword
    title: Def Keyword Fill-in
    difficulty: 1
    concept: functions
    subconcept: fn-basics
    level: intro
    prereqs: []
    type: fill-in
    blank_position: 0
    pattern: definition
    prompt: "Fill in the keyword: `___ foo():`"
    template: "___ {{action_verb}}_{{item_singular}}({{item_singular}}):"
    expected_answer: "def"
    hints:
      - Keyword that starts function definition
      - Short for "define"
    tags: [functions, def, fill-in]

  - slug: return-keyword-fill
    objective: Complete the return statement
    title: Return Fill-in
    difficulty: 1
    concept: functions
    subconcept: fn-basics
    level: intro
    prereqs: [fn-basics]
    type: fill-in
    blank_position: 0
    pattern: definition
    prompt: "Fill in the keyword: `___ x`"
    template: |
      def get_{{item_singular}}({{id_var}}):
          ___ {{id_var}}
    expected_answer: "return"
    hints:
      - Keyword to send value back to caller
      - Exits the function immediately
    tags: [functions, return, fill-in]

  - slug: lambda-keyword-fill
    objective: Complete the lambda expression
    title: Lambda Fill-in
    difficulty: 2
    concept: functions
    subconcept: lambda
    level: intro
    prereqs: [fn-basics]
    type: fill-in
    blank_position: 0
    pattern: definition
    prompt: "Fill in the keyword: `___ x: x * 2`"
    template: "double_{{item_singular}} = ___ {{item_singular}}_count: {{item_singular}}_count * 2"
    expected_answer: "lambda"
    hints:
      - Keyword for anonymous functions
      - Single expression, no `return` keyword needed
    tags: [functions, lambda, fill-in]

  - slug: default-value-fill
    objective: Complete the default parameter syntax
    title: Default Value Fill-in
    difficulty: 2
    concept: functions
    subconcept: defaults
    level: practice
    prereqs: [fn-basics]
    type: fill-in
    blank_position: 0
    pattern: definition
    prompt: "Fill in the operator for default parameter value: `def f(x ___ 1):`"
    template: 'def add_{{item_singular}}({{item_singular}}, {{status_var}}___False):'
    expected_answer: "="
    hints:
      - Assignment operator for defaults
      - Same symbol used in regular assignment
    tags: [functions, defaults, fill-in]

  - slug: args-syntax-fill
    objective: Complete the variable arguments syntax
    title: Args Syntax Fill-in
    difficulty: 2
    concept: functions
    subconcept: args-kwargs
    level: practice
    prereqs: [fn-basics]
    type: fill-in
    blank_position: 0
    pattern: definition
    prompt: "Fill in the symbol for variable positional arguments: `___args`"
    template: "def combine_{{list_name}}(___args):"
    expected_answer: "*"
    hints:
      - Single asterisk for positional args
      - Collects all remaining positional arguments
    tags: [functions, args, fill-in]

  - slug: kwargs-syntax-fill
    objective: Complete the keyword arguments syntax
    title: Kwargs Syntax Fill-in
    difficulty: 2
    concept: functions
    subconcept: args-kwargs
    level: practice
    prereqs: [args-kwargs]
    type: fill-in
    blank_position: 0
    pattern: definition
    prompt: "Fill in the symbol for variable keyword arguments: `___kwargs`"
    template: "def build_{{item_singular}}(___kwargs):"
    expected_answer: "**"
    hints:
      - Double asterisk for keyword args
      - Collects all remaining keyword arguments as a dict
    tags: [functions, kwargs, fill-in]

  # --- Predict Exercises ---
  - slug: function-return-predict
    objective: Predict function return value
    title: Return Value Predict
    difficulty: 1
    concept: functions
    subconcept: fn-basics
    level: intro
    prereqs: [fn-basics]
    type: predict
    grading_strategy: execution
    pattern: invocation
    prompt: What does this function addition code print?
    code: |
      def add_{{item_plural}}({{attr_key_1}}, {{attr_key_2}}):
          return {{attr_key_1}} + {{attr_key_2}}
      print(add_{{item_plural}}(3, 4))
    expected_answer: "7"
    hints:
      - Function returns sum of {{item_singular}} arguments
      - add_{{item_plural}}(3, 4) computes 3 + 4
    tags: [functions, return, predict]

  - slug: default-param-predict
    objective: Predict behavior with default parameters
    title: Default Param Predict
    difficulty: 2
    concept: functions
    subconcept: defaults
    level: practice
    prereqs: [defaults]
    type: predict
    grading_strategy: execution
    pattern: invocation
    prompt: What does this default parameter code print?
    code: |
      def {{action_verb}}_{{item_singular}}({{item_singular}}_name, {{status_var}}="{{item_example}}"):
          return f"{{{status_var}}}, {{{item_singular}}_name}!"
      print({{action_verb}}_{{item_singular}}("User"))
    expected_answer: "{{item_example}}, User!"
    hints:
      - Default value is used when not provided
      - Only {{item_singular}}_name is passed, so {{status_var}} uses its default
    tags: [functions, defaults, predict]

  - slug: lambda-predict
    objective: Predict lambda expression result
    title: Lambda Predict
    difficulty: 2
    concept: functions
    subconcept: lambda
    level: practice
    prereqs: [lambda]
    type: predict
    grading_strategy: execution
    pattern: invocation
    prompt: What does this lambda expression print?
    code: |
      double_{{item_singular}} = lambda {{item_singular}}_count: {{item_singular}}_count * 2
      print(double_{{item_singular}}(5))
    expected_answer: "10"
    hints:
      - Lambda multiplies {{item_singular}}_count by 2
      - double_{{item_singular}}(5) evaluates 5 * 2
    tags: [functions, lambda, predict]

  - slug: scope-predict
    objective: Predict variable scope behavior
    title: Scope Predict
    difficulty: 3
    concept: functions
    subconcept: scope
    level: practice
    prereqs: [scope]
    type: predict
    grading_strategy: execution
    pattern: scope
    prompt: What does this variable scope code print?
    code: |
      {{item_singular}}_count = 10
      def {{action_verb}}_{{item_singular}}():
          {{item_singular}}_count = 20
          print({{item_singular}}_count)
      {{action_verb}}_{{item_singular}}()
      print({{item_singular}}_count)
    expected_answer: |
      20
      10
    hints:
      - Local {{item_singular}}_count shadows global inside function
      - Global {{item_singular}}_count is unchanged after function returns
    tags: [functions, scope, predict]

  - slug: args-predict
    objective: Predict *args behavior
    title: Args Predict
    difficulty: 2
    concept: functions
    subconcept: args-kwargs
    level: practice
    prereqs: [args-kwargs]
    type: predict
    grading_strategy: execution
    pattern: invocation
    prompt: What does this *args code print?
    code: |
      def count_{{item_plural}}(*args):
          print(len(args))
      count_{{item_plural}}(1, 2, 3, 4)
    expected_answer: "4"
    hints:
      - args is a tuple of all {{item_singular}} arguments
      - 4 {{item_plural}} were passed to count_{{item_plural}}()
    tags: [functions, args, predict]

  - slug: mutable-default-predict
    objective: Predict mutable default argument bug
    title: Mutable Default Predict
    difficulty: 3
    concept: functions
    subconcept: defaults
    level: edge
    prereqs: [defaults]
    type: predict
    grading_strategy: execution
    pattern: gotcha
    prompt: What does this mutable default code print?
    code: |
      def add_{{item_singular}}({{item_singular}}, {{list_name}}=[]):
          {{list_name}}.append({{item_singular}})
          return {{list_name}}
      print(add_{{item_singular}}(1))
      print(add_{{item_singular}}(2))
    expected_answer: |
      [1]
      [1, 2]
    hints:
      - Mutable defaults are shared between {{item_singular}} calls
      - This is a common Python gotcha
    tags: [functions, mutable, gotcha, predict]

  # --- Dynamic Exercises (using generators) ---
  - slug: function-call-dynamic
    objective: "Predict the return value of a realistic function call"
    title: Dynamic Function Call
    difficulty: 2
    concept: functions
    subconcept: fn-basics
    level: practice
    prereqs: [fn-basics]
    type: predict
    grading_strategy: execution
    pattern: invocation
    generator: function-call
    prompt: "What does {{funcName}}({{argList}}) return?"
    code: "{{code}}"
    expected_answer: "{{result}}"
    hints:
      - Trace through the function with the given arguments
      - Functions compute and return values
    tags: [functions, dynamic, predict]

  - slug: function-call-write-dynamic
    objective: "Write the correct function call syntax"
    title: Dynamic Function Call Write
    difficulty: 2
    concept: functions
    subconcept: fn-basics
    level: practice
    prereqs: [fn-basics]
    type: write
    pattern: invocation
    generator: function-call
    prompt: "Call {{funcName}} with arguments {{argList}}"
    expected_answer: "{{funcName}}({{argList}})"
    accepted_solutions:
      - "{{funcName}}({{argList}})"
    hints:
      - Function calls use parentheses
      - Pass arguments in order
    tags: [functions, call, dynamic, write]

  - slug: function-result-predict-dynamic
    objective: "Predict the computed result of a function"
    title: Dynamic Function Result
    difficulty: 2
    concept: functions
    subconcept: fn-basics
    level: practice
    prereqs: [fn-basics]
    type: predict
    grading_strategy: execution
    pattern: invocation
    generator: function-call
    prompt: "What does this function call return?"
    code: "{{code}}"
    expected_answer: "{{result}}"
    hints:
      - Substitute the argument values
      - Perform the computation
    tags: [functions, return, dynamic, predict]

  - slug: lambda-result-dynamic
    objective: "Predict the result of calling a lambda expression"
    title: Dynamic Lambda Result
    difficulty: 2
    concept: functions
    subconcept: lambda
    level: practice
    prereqs: [lambda]
    type: predict
    grading_strategy: execution
    pattern: invocation
    generator: lambda-expr
    prompt: "What does this code print?"
    code: |
      {{opName}} = {{lambdaExpr}}
      print({{opName}}({{argList}}))
    expected_answer: "{{result}}"
    hints:
      - The lambda {{description}}
      - Substitute the arguments into the expression
    tags: [functions, lambda, dynamic, predict]
    target_construct:
      type: lambda
      feedback: "Lambdas are concise anonymous functions"

  - slug: lambda-write-dynamic
    objective: "Write a lambda expression that performs the operation"
    title: Dynamic Lambda Write
    difficulty: 2
    concept: functions
    subconcept: lambda
    level: practice
    prereqs: [lambda]
    type: write
    pattern: definition
    generator: lambda-expr
    prompt: "Write a lambda that {{description}}"
    expected_answer: "{{lambdaExpr}}"
    accepted_solutions:
      - "{{lambdaExpr}}"
    hints:
      - "Lambda syntax: lambda params: expression"
      - "Use the parameters {{params}}"
    tags: [functions, lambda, dynamic, write]
    target_construct:
      type: lambda
      feedback: "Use lambda for simple one-expression functions"

  - slug: lambda-call-dynamic
    objective: "Call a lambda with specific arguments"
    title: Dynamic Lambda Call
    difficulty: 2
    concept: functions
    subconcept: lambda
    level: practice
    prereqs: [lambda]
    type: write
    pattern: invocation
    generator: lambda-expr
    prompt: "Call the lambda {{opName}} = {{lambdaExpr}} with arguments {{argList}}"
    expected_answer: "{{opName}}({{argList}})"
    accepted_solutions:
      - "{{opName}}({{argList}})"
    hints:
      - Call lambdas just like regular functions
      - Use parentheses with arguments inside
    tags: [functions, lambda, call, dynamic]

  # --- Default Arguments Dynamic Exercises ---
  - slug: default-args-predict-dynamic
    objective: Predict function output with default arguments
    title: Dynamic Default Args Predict
    difficulty: 2
    concept: functions
    subconcept: defaults
    level: practice
    prereqs: [fn-basics]
    type: predict
    grading_strategy: execution
    pattern: invocation
    generator: default-args
    prompt: "What does this code print?"
    code: "{{code}}"
    expected_answer: "{{result}}"
    hints:
      - "The function {{description}}"
      - "Check if default values are used"
    tags: [functions, defaults, dynamic, predict]

  - slug: default-args-call-dynamic
    objective: Call a function using its default parameters
    title: Dynamic Default Args Call
    difficulty: 2
    concept: functions
    subconcept: defaults
    level: practice
    prereqs: [defaults]
    type: write
    pattern: invocation
    generator: default-args
    prompt: "Given def {{funcName}}({{params}}), call it to get the result '{{result}}'"
    expected_answer: "{{funcName}}({{callArgs}})"
    accepted_solutions:
      - "{{funcName}}({{callArgs}})"
    hints:
      - "Default parameters can be omitted"
      - "Explicit args override defaults"
    tags: [functions, defaults, dynamic, write]

  # --- Integrated Exercises (Premium - Combining Multiple Subconcepts) ---
  - slug: config-loader-integrated
    objective: Build a safe config loader combining context managers, try-except, and dict handling
    title: Safe JSON Config Loader
    difficulty: 3
    concept: functions
    subconcept: fn-basics
    level: edge
    prereqs: [context, try-except, imports-basic, dicts]
    type: write
    pattern: definition
    prompt: |
      Write `load_config(path)` that safely loads a JSON file using a context manager.
      Return `{}` if `FileNotFoundError` or `json.JSONDecodeError` occurs.
      Assume `json` is already imported.
    expected_answer: |
      def load_config(path):
          try:
              with open(path) as f:
                  return json.load(f)
          except (FileNotFoundError, json.JSONDecodeError):
              return {}
    accepted_solutions:
      - |
        def load_config(path):
            try:
                with open(path, 'r') as f:
                    return json.load(f)
            except (FileNotFoundError, json.JSONDecodeError):
                return {}
      - |
        def load_config(path):
            try:
                with open(path) as file:
                    return json.load(file)
            except (FileNotFoundError, json.JSONDecodeError):
                return {}
    hints:
      - Use `with` statement for file handling
      - Catch multiple exceptions with a tuple
      - Return empty dict on error
    tags: [context-manager, json, error-handling]
  # --- Debug Exercises (Pitfall Subconcepts) ---