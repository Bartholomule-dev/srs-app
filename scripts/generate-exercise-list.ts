// scripts/generate-exercise-list.ts
// AUTO-GENERATES Exercise-List.md from YAML source of truth
// Usage: npx tsx scripts/generate-exercise-list.ts [--obsidian /path/to/vault]

import { readFileSync, readdirSync, writeFileSync, existsSync, mkdirSync } from 'fs';
import { parse } from 'yaml';
import { join } from 'path';

interface Exercise {
  slug: string;
  title: string;
  prompt: string;
  expected_answer: string;
  type: 'write' | 'fill-in' | 'predict';
  level: 'intro' | 'practice' | 'edge' | 'integrated';
  concept: string;
  subconcept: string;
  generator?: string;
  code?: string;
}

interface YamlFile {
  language: string;
  category: string;
  exercises: Exercise[];
}

interface Stats {
  total: number;
  byType: Record<string, number>;
  byLevel: Record<string, number>;
  byConcept: Record<string, number>;
  bySubconcept: Record<string, Record<string, Exercise[]>>;
  dynamic: number;
  duplicates: string[];
}

const TYPE_ABBREV: Record<string, string> = {
  write: 'W',
  'fill-in': 'F',
  predict: 'P',
};

const LEVEL_ABBREV: Record<string, string> = {
  intro: 'I',
  practice: 'P',
  edge: 'E',
  integrated: 'Int',
};

function parseAllYaml(): { exercises: Exercise[]; stats: Stats } {
  const exercisesDir = join(process.cwd(), 'exercises/python');
  const files = readdirSync(exercisesDir).filter(f => f.endsWith('.yaml'));

  const allExercises: Exercise[] = [];
  const slugSet = new Set<string>();
  const duplicates: string[] = [];

  for (const file of files) {
    const filePath = join(exercisesDir, file);
    const content = readFileSync(filePath, 'utf-8');
    const data = parse(content) as YamlFile;

    for (const exercise of data.exercises) {
      if (slugSet.has(exercise.slug)) {
        duplicates.push(exercise.slug);
      }
      slugSet.add(exercise.slug);
      allExercises.push(exercise);
    }
  }

  // Compute stats
  const stats: Stats = {
    total: allExercises.length,
    byType: {},
    byLevel: {},
    byConcept: {},
    bySubconcept: {},
    dynamic: 0,
    duplicates,
  };

  for (const ex of allExercises) {
    // By type
    stats.byType[ex.type] = (stats.byType[ex.type] || 0) + 1;

    // By level
    stats.byLevel[ex.level] = (stats.byLevel[ex.level] || 0) + 1;

    // By concept
    stats.byConcept[ex.concept] = (stats.byConcept[ex.concept] || 0) + 1;

    // By subconcept (grouped under concept)
    if (!stats.bySubconcept[ex.concept]) {
      stats.bySubconcept[ex.concept] = {};
    }
    if (!stats.bySubconcept[ex.concept][ex.subconcept]) {
      stats.bySubconcept[ex.concept][ex.subconcept] = [];
    }
    stats.bySubconcept[ex.concept][ex.subconcept].push(ex);

    // Dynamic count
    if (ex.generator) {
      stats.dynamic++;
    }
  }

  return { exercises: allExercises, stats };
}

function truncateText(text: string, maxLen = 80): string {
  if (text.length <= maxLen) return text;
  return text.slice(0, maxLen - 3) + '...';
}

function escapeMarkdown(text: string): string {
  return text.replace(/\|/g, '\\|').replace(/\n/g, ' ');
}

function generateMarkdown(stats: Stats): string {
  const lines: string[] = [];

  // Header with warning
  lines.push('<!-- AUTO-GENERATED FILE - DO NOT EDIT -->');
  lines.push('<!-- Generated by: npx tsx scripts/generate-exercise-list.ts -->');
  lines.push('<!-- Source of truth: exercises/python/*.yaml -->');
  lines.push('');
  lines.push('# Exercise List - Complete');
  lines.push('');
  lines.push(`> **${stats.total} exercises** across ${Object.keys(stats.byConcept).length} concepts`);
  lines.push('');
  lines.push('---');
  lines.push('');

  // Summary table
  lines.push('## Summary');
  lines.push('');
  lines.push('| Type | Count | Level | Count |');
  lines.push('|------|-------|-------|-------|');
  lines.push(`| write | ${stats.byType.write || 0} | intro | ${stats.byLevel.intro || 0} |`);
  lines.push(`| fill-in | ${stats.byType['fill-in'] || 0} | practice | ${stats.byLevel.practice || 0} |`);
  lines.push(`| predict | ${stats.byType.predict || 0} | edge | ${stats.byLevel.edge || 0} |`);
  lines.push(`| **Dynamic** | **${stats.dynamic}** | integrated | ${stats.byLevel.integrated || 0} |`);
  lines.push('');

  // Duplicates warning
  if (stats.duplicates.length > 0) {
    lines.push('> ‚ö†Ô∏è **Duplicate slugs found:** ' + stats.duplicates.join(', '));
    lines.push('');
  }

  lines.push('---');
  lines.push('');

  // Contents (sorted by concept name)
  lines.push('## Contents');
  lines.push('');
  const sortedConcepts = Object.keys(stats.byConcept).sort();
  for (const concept of sortedConcepts) {
    lines.push(`- [[#^${concept}|${concept}]] (${stats.byConcept[concept]})`);
  }
  lines.push('');
  lines.push('---');
  lines.push('');

  // Each concept section
  for (const concept of sortedConcepts) {
    const conceptCount = stats.byConcept[concept];
    lines.push(`## ${capitalize(concept)} (${conceptCount})`);
    lines.push(`^${concept}`);
    lines.push('');

    const subconcepts = stats.bySubconcept[concept];
    const sortedSubconcepts = Object.keys(subconcepts).sort();

    for (const subconcept of sortedSubconcepts) {
      const exercises = subconcepts[subconcept];
      lines.push(`### ${subconcept} (${exercises.length})`);
      lines.push('');
      lines.push('| # | Type | Level | Prompt | Code | Answer | Dyn |');
      lines.push('|---|------|-------|--------|------|--------|-----|');

      // Sort exercises by level order, then by slug
      const levelOrder = ['intro', 'practice', 'edge', 'integrated'];
      const sorted = [...exercises].sort((a, b) => {
        const levelDiff = levelOrder.indexOf(a.level) - levelOrder.indexOf(b.level);
        if (levelDiff !== 0) return levelDiff;
        return a.slug.localeCompare(b.slug);
      });

      sorted.forEach((ex, i) => {
        const typeAbbrev = TYPE_ABBREV[ex.type] || ex.type;
        const levelAbbrev = LEVEL_ABBREV[ex.level] || ex.level;
        const prompt = escapeMarkdown(truncateText(ex.prompt));
        const code = ex.code ? '`' + escapeMarkdown(truncateText(ex.code, 60)) + '`' : '';
        const answer = '`' + escapeMarkdown(truncateText(ex.expected_answer, 50)) + '`';
        const dynamic = ex.generator ? '‚úì' : '';
        lines.push(`| ${i + 1} | ${typeAbbrev} | ${levelAbbrev} | ${prompt} | ${code} | ${answer} | ${dynamic} |`);
      });

      lines.push('');
    }

    lines.push('---');
    lines.push('');
  }

  // Legend
  lines.push('## Legend');
  lines.push('');
  lines.push('| Column | Meaning |');
  lines.push('|--------|---------|');
  lines.push('| **Type** | W=Write, F=Fill-in, P=Predict |');
  lines.push('| **Level** | I=Intro, P=Practice, E=Edge, Int=Integrated |');
  lines.push('| **Code** | Code snippet for predict exercises |');
  lines.push('| **Dyn** | ‚úì = Dynamic exercise (values change) |');
  lines.push('');
  lines.push('---');
  lines.push('');

  // Timestamp
  const now = new Date().toISOString().split('T')[0];
  lines.push(`*Generated: ${now} from YAML source of truth*`);

  return lines.join('\n');
}

function capitalize(s: string): string {
  return s.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
}

function main() {
  console.log('üìã Parsing YAML files...');
  const { stats } = parseAllYaml();

  console.log(`\nüìä Statistics:`);
  console.log(`   Total exercises: ${stats.total}`);
  console.log(`   Dynamic: ${stats.dynamic}`);
  console.log(`   By type: write=${stats.byType.write || 0}, fill-in=${stats.byType['fill-in'] || 0}, predict=${stats.byType.predict || 0}`);
  console.log(`   By level: intro=${stats.byLevel.intro || 0}, practice=${stats.byLevel.practice || 0}, edge=${stats.byLevel.edge || 0}, integrated=${stats.byLevel.integrated || 0}`);

  if (stats.duplicates.length > 0) {
    console.log(`\n‚ö†Ô∏è  Duplicates found: ${stats.duplicates.join(', ')}`);
  }

  console.log('\nüìù Generating markdown...');
  const markdown = generateMarkdown(stats);

  // Write to docs/
  const docsDir = join(process.cwd(), 'docs');
  if (!existsSync(docsDir)) {
    mkdirSync(docsDir, { recursive: true });
  }
  const docsPath = join(docsDir, 'EXERCISES.md');
  writeFileSync(docsPath, markdown);
  console.log(`‚úì Written to ${docsPath}`);

  // Check for --obsidian flag
  const obsidianIndex = process.argv.indexOf('--obsidian');
  if (obsidianIndex !== -1 && process.argv[obsidianIndex + 1]) {
    const obsidianPath = join(process.argv[obsidianIndex + 1], 'SRS-app', 'Exercise-List.md');
    writeFileSync(obsidianPath, markdown);
    console.log(`‚úì Written to ${obsidianPath}`);
  }

  console.log('\n‚úÖ Done!');

  // Return stats for validation
  return stats;
}

// Export for use in validation
export { parseAllYaml };
export type { Stats };

main();
