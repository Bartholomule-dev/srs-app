// scripts/generate-integrated-index.ts
import { readFileSync, readdirSync, writeFileSync } from 'fs';
import { join } from 'path';
import { parse } from 'yaml';

interface Exercise {
  slug: string;
  title: string;
  level: string;
  concept: string;
  subconcept: string;
  type: string;
  targets?: string[];
}

interface YamlFile {
  exercises: Exercise[];
}

interface Curriculum {
  concepts: { slug: string; name: string; subconcepts: string[] }[];
  subconcepts: Record<string, { name: string }>;
}

const exercisesDir = join(process.cwd(), 'exercises', 'python');
const curriculumPath = join(process.cwd(), 'src', 'lib', 'curriculum', 'python.json');
const outputPath = join(process.cwd(), 'docs', 'integrated-exercises.md');

const curriculum = JSON.parse(readFileSync(curriculumPath, 'utf-8')) as Curriculum;
const conceptName = new Map(curriculum.concepts.map(c => [c.slug, c.name]));
const subconceptName = new Map(
  Object.entries(curriculum.subconcepts).map(([slug, data]) => [slug, data.name])
);

const files = readdirSync(exercisesDir).filter(f => f.endsWith('.yaml')).sort();

const grouped = new Map<
  string,
  Map<string, { exercise: Exercise; file: string }[]>
>();

let totalCount = 0;

for (const file of files) {
  const filePath = join(exercisesDir, file);
  const data = parse(readFileSync(filePath, 'utf-8')) as YamlFile;

  for (const exercise of data.exercises || []) {
    if (exercise.level !== 'integrated') continue;
    totalCount += 1;

    const conceptGroup = grouped.get(exercise.concept) ?? new Map();
    const subGroup = conceptGroup.get(exercise.subconcept) ?? [];
    subGroup.push({ exercise, file });
    conceptGroup.set(exercise.subconcept, subGroup);
    grouped.set(exercise.concept, conceptGroup);
  }
}

const lines: string[] = [];
lines.push('<!-- AUTO-GENERATED FILE - DO NOT EDIT -->');
lines.push('<!-- Generated by: npx tsx scripts/generate-integrated-index.ts -->');
lines.push('<!-- Source of truth: exercises/python/*.yaml -->');
lines.push('');
lines.push('# Integrated Exercise Index');
lines.push('');
lines.push(`> **${totalCount} integrated exercises** across ${curriculum.concepts.length} concepts`);
lines.push('');
lines.push('---');
lines.push('');

for (const concept of curriculum.concepts) {
  const conceptGroup = grouped.get(concept.slug);
  if (!conceptGroup) continue;

  const conceptCount = Array.from(conceptGroup.values()).reduce(
    (sum, list) => sum + list.length,
    0
  );
  if (conceptCount === 0) continue;

  const conceptLabel = conceptName.get(concept.slug) ?? concept.slug;
  lines.push(`## ${conceptLabel} (${conceptCount})`);
  lines.push('');

  for (const subconceptSlug of concept.subconcepts) {
    const subList = conceptGroup.get(subconceptSlug);
    if (!subList || subList.length === 0) continue;

    const subLabel = subconceptName.get(subconceptSlug) ?? subconceptSlug;
    lines.push(`### ${subLabel} (${subList.length})`);
    lines.push('');

    const sorted = [...subList].sort((a, b) =>
      a.exercise.slug.localeCompare(b.exercise.slug)
    );

    for (const { exercise, file } of sorted) {
      const targets = exercise.targets?.length
        ? ` targets: ${exercise.targets.join(', ')}`
        : '';
      lines.push(
        `- \`${exercise.slug}\` - ${exercise.title} (${exercise.type})${targets} - exercises/python/${file}`
      );
    }

    lines.push('');
  }
}

writeFileSync(outputPath, `${lines.join('\n')}\n`, 'utf-8');
console.log(`Wrote ${outputPath}`);
