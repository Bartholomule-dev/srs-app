# Phase 2.5: Curriculum Enhancement - Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Add `objective` and `targets` fields to exercises, implement anti-repeat pattern selection, multi-subconcept SRS credit, and expand curriculum coverage.

**Architecture:** Extend existing schema with two new fields. Modify session selection to track last pattern and avoid repeats. Update SRS to credit multiple subconcepts for integrated exercises. Add new subconcepts to curriculum graph and create exercises.

**Tech Stack:** TypeScript, Supabase (PostgreSQL), Vitest, JSON Schema validation, React hooks.

---

## Part A: Schema & Infrastructure

### Task A1: Add `objective` and `targets` to JSON Schema

**Files:**
- Modify: `exercises/schema.json`

**Step 1: Add new field definitions to schema**

Open `exercises/schema.json` and add the following properties inside `definitions.exercise.properties`:

```json
"objective": {
  "type": "string",
  "minLength": 10,
  "maxLength": 150,
  "pattern": "^[A-Z][a-z]",
  "description": "Learning objective (start with verb, 10-150 chars)"
},
"targets": {
  "type": "array",
  "items": { "type": "string" },
  "description": "Subconcepts tested (required for integrated, optional otherwise)"
}
```

**Step 2: Update required array to include objective**

Change line 24 from:
```json
"required": ["slug", "title", "prompt", "expected_answer", "hints", "concept", "subconcept", "level", "prereqs", "type", "pattern"],
```

To:
```json
"required": ["slug", "title", "prompt", "expected_answer", "hints", "concept", "subconcept", "level", "prereqs", "type", "pattern", "objective"],
```

**Step 3: Add conditional validation for targets**

Add a new condition to the `allOf` array (after the fill-in condition):

```json
{
  "if": {
    "properties": { "level": { "const": "integrated" } },
    "required": ["level"]
  },
  "then": { "required": ["targets"] }
}
```

**Step 4: Run schema validation to confirm syntax**

Run: `node -e "JSON.parse(require('fs').readFileSync('exercises/schema.json'))"`
Expected: No output (valid JSON)

**Step 5: Commit**

```bash
git add exercises/schema.json
git commit -m "feat(schema): add objective and targets fields to exercise schema"
```

---

### Task A2: Update TypeScript Types

**Files:**
- Modify: `src/lib/exercise/yaml-types.ts`
- Modify: `src/lib/types/app.types.ts`

**Step 1: Add fields to YamlExercise interface**

In `src/lib/exercise/yaml-types.ts`, add after line 30 (`pattern: ExercisePattern;`):

```typescript
  // Learning objective
  objective: string;

  // Multi-subconcept targeting (required for integrated)
  targets?: string[];
```

**Step 2: Add fields to Exercise interface**

In `src/lib/types/app.types.ts`, add after line 65 (`pattern: ExercisePattern;`):

```typescript
  // Learning objective
  objective: string;

  // Multi-subconcept targeting (for integrated exercises)
  targets: string[] | null;
```

**Step 3: Run typecheck**

Run: `pnpm typecheck`
Expected: Errors in mappers.ts (new fields not mapped yet)

**Step 4: Commit**

```bash
git add src/lib/exercise/yaml-types.ts src/lib/types/app.types.ts
git commit -m "feat(types): add objective and targets to Exercise types"
```

---

### Task A3: Update Database Migration

**Files:**
- Create: `supabase/migrations/20260106000001_add_objective_targets.sql`

**Step 1: Create migration file**

```sql
-- Add objective and targets columns to exercises table

-- objective: Learning target for each exercise (required)
ALTER TABLE exercises
ADD COLUMN objective TEXT;

-- targets: Array of subconcepts tested (for integrated exercises)
ALTER TABLE exercises
ADD COLUMN targets TEXT[];

-- Add comment documentation
COMMENT ON COLUMN exercises.objective IS 'Learning objective: what skill this exercise teaches';
COMMENT ON COLUMN exercises.targets IS 'Subconcepts tested by this exercise (required for integrated level)';
```

Note: We don't add NOT NULL constraint yet - will be enforced after backfill.

**Step 2: Apply migration locally**

Run: `pnpm db:reset`
Expected: Migration applies successfully

**Step 3: Regenerate TypeScript types**

Run: `pnpm db:types`
Expected: New columns appear in database.generated.ts

**Step 4: Commit**

```bash
git add supabase/migrations/20260106000001_add_objective_targets.sql src/lib/types/database.generated.ts
git commit -m "feat(db): add objective and targets columns to exercises"
```

---

### Task A4: Update Exercise Mapper

**Files:**
- Modify: `src/lib/supabase/mappers.ts`
- Modify: `tests/unit/srs/mappers.test.ts`

**Step 1: Write failing test**

Add to `tests/unit/srs/mappers.test.ts`:

```typescript
describe('mapExercise objective and targets', () => {
  it('maps objective field', () => {
    const db = {
      ...mockDbExercise,
      objective: 'Use enumerate to iterate with index',
    };
    const result = mapExercise(db);
    expect(result.objective).toBe('Use enumerate to iterate with index');
  });

  it('maps targets array', () => {
    const db = {
      ...mockDbExercise,
      targets: ['for', 'enumerate', 'list-comp'],
    };
    const result = mapExercise(db);
    expect(result.targets).toEqual(['for', 'enumerate', 'list-comp']);
  });

  it('maps null targets when not provided', () => {
    const db = {
      ...mockDbExercise,
      targets: null,
    };
    const result = mapExercise(db);
    expect(result.targets).toBeNull();
  });

  it('defaults objective to empty string when null', () => {
    const db = {
      ...mockDbExercise,
      objective: null,
    };
    const result = mapExercise(db);
    expect(result.objective).toBe('');
  });
});
```

**Step 2: Run test to verify it fails**

Run: `pnpm test tests/unit/srs/mappers.test.ts`
Expected: FAIL - objective/targets properties don't exist on result

**Step 3: Update mapExercise function**

In `src/lib/supabase/mappers.ts`, add after line 57 (`blankPosition: db.blank_position ?? null,`):

```typescript
    // Phase 2.5 fields
    objective: db.objective ?? '',
    targets: db.targets ?? null,
```

**Step 4: Run test to verify it passes**

Run: `pnpm test tests/unit/srs/mappers.test.ts`
Expected: All tests PASS

**Step 5: Run full typecheck**

Run: `pnpm typecheck`
Expected: PASS

**Step 6: Commit**

```bash
git add src/lib/supabase/mappers.ts tests/unit/srs/mappers.test.ts
git commit -m "feat(mappers): add objective and targets to mapExercise"
```

---

### Task A5: Update Import Script

**Files:**
- Modify: `scripts/import-exercises.ts`

**Step 1: Add new fields to row object**

In `scripts/import-exercises.ts`, update the `row` object in `importToDatabase` function (around line 140).

Add after line 160 (`blank_position: exercise.blank_position ?? null,`):

```typescript
        objective: exercise.objective,
        targets: exercise.targets ?? null,
```

**Step 2: Test import script syntax**

Run: `pnpm typecheck`
Expected: PASS (or errors about missing objective in YAML - expected until backfill)

**Step 3: Commit**

```bash
git add scripts/import-exercises.ts
git commit -m "feat(import): add objective and targets to exercise import"
```

---

## Part B: Algorithm Changes

### Task B1: Add Session State for Pattern Tracking (TDD)

**Files:**
- Modify: `src/lib/hooks/useConceptSession.ts`
- Create: `tests/unit/hooks/useConceptSession-antirepeat.test.ts`

**Step 1: Write failing test for anti-repeat**

Create `tests/unit/hooks/useConceptSession-antirepeat.test.ts`:

```typescript
import { describe, it, expect } from 'vitest';
import { selectWithAntiRepeat } from '@/lib/session/anti-repeat';
import type { Exercise } from '@/lib/types';
import type { SubconceptProgress } from '@/lib/curriculum/types';

const createMockExercise = (slug: string, pattern: string, subconcept: string): Exercise => ({
  id: slug,
  slug,
  language: 'python',
  category: 'test',
  difficulty: 1,
  title: slug,
  prompt: 'test',
  expectedAnswer: 'test',
  acceptedSolutions: [],
  hints: [],
  explanation: null,
  tags: [],
  timesPracticed: 0,
  avgSuccessRate: null,
  createdAt: '',
  updatedAt: '',
  concept: 'control-flow',
  subconcept,
  level: 'intro',
  prereqs: [],
  exerciseType: 'write',
  pattern: pattern as Exercise['pattern'],
  template: null,
  blankPosition: null,
  objective: 'Test objective',
  targets: null,
});

const createMockProgress = (subconcept: string): SubconceptProgress => ({
  id: '1',
  userId: 'user-1',
  subconceptSlug: subconcept,
  conceptSlug: 'control-flow',
  phase: 'learning',
  easeFactor: 2.5,
  interval: 0,
  nextReview: new Date(),
  lastReviewed: null,
  createdAt: new Date(),
  updatedAt: new Date(),
});

describe('selectWithAntiRepeat', () => {
  it('returns any candidate when lastPattern is null', () => {
    const candidates = [
      { exercise: createMockExercise('ex1', 'iteration', 'for'), progress: createMockProgress('for') },
    ];

    const result = selectWithAntiRepeat(candidates, null);

    expect(result).not.toBeNull();
    expect(result?.exercise.slug).toBe('ex1');
  });

  it('prefers candidates with different pattern than lastPattern', () => {
    const candidates = [
      { exercise: createMockExercise('ex1', 'iteration', 'for'), progress: createMockProgress('for') },
      { exercise: createMockExercise('ex2', 'accumulator', 'while'), progress: createMockProgress('while') },
    ];

    const result = selectWithAntiRepeat(candidates, 'iteration');

    expect(result?.exercise.pattern).toBe('accumulator');
  });

  it('falls back to same pattern if no alternatives exist', () => {
    const candidates = [
      { exercise: createMockExercise('ex1', 'iteration', 'for'), progress: createMockProgress('for') },
      { exercise: createMockExercise('ex2', 'iteration', 'while'), progress: createMockProgress('while') },
    ];

    const result = selectWithAntiRepeat(candidates, 'iteration');

    expect(result).not.toBeNull();
    expect(result?.exercise.pattern).toBe('iteration');
  });

  it('returns null when no candidates', () => {
    const result = selectWithAntiRepeat([], 'iteration');
    expect(result).toBeNull();
  });
});
```

**Step 2: Run test to verify it fails**

Run: `pnpm test tests/unit/hooks/useConceptSession-antirepeat.test.ts`
Expected: FAIL - module not found

**Step 3: Create anti-repeat module**

Create `src/lib/session/anti-repeat.ts`:

```typescript
// src/lib/session/anti-repeat.ts
// Anti-repeat pattern selection for session variety

import type { Exercise } from '@/lib/types';
import type { ExercisePattern, SubconceptProgress } from '@/lib/curriculum/types';

export interface SelectionCandidate {
  exercise: Exercise;
  progress: SubconceptProgress;
}

/**
 * Select next candidate while avoiding same pattern as last exercise.
 * Falls back to same pattern if no alternatives exist.
 */
export function selectWithAntiRepeat(
  candidates: SelectionCandidate[],
  lastPattern: ExercisePattern | null
): SelectionCandidate | null {
  if (candidates.length === 0) {
    return null;
  }

  if (lastPattern === null) {
    return candidates[0];
  }

  // Prefer candidates with different pattern
  const differentPattern = candidates.filter(
    (c) => c.exercise.pattern !== lastPattern
  );

  if (differentPattern.length > 0) {
    return differentPattern[0];
  }

  // Fallback to same pattern
  return candidates[0];
}
```

**Step 4: Export from session index**

Add to `src/lib/session/index.ts`:

```typescript
export { selectWithAntiRepeat } from './anti-repeat';
export type { SelectionCandidate } from './anti-repeat';
```

**Step 5: Run test to verify it passes**

Run: `pnpm test tests/unit/hooks/useConceptSession-antirepeat.test.ts`
Expected: All tests PASS

**Step 6: Commit**

```bash
git add src/lib/session/anti-repeat.ts src/lib/session/index.ts tests/unit/hooks/useConceptSession-antirepeat.test.ts
git commit -m "feat(session): add anti-repeat pattern selection algorithm"
```

---

### Task B2: Integrate Anti-Repeat into Session Hook

**Files:**
- Modify: `src/lib/hooks/useConceptSession.ts`

**Step 1: Add state for last pattern**

Add after line 84 (`const [forceComplete, setForceComplete] = useState(false);`):

```typescript
  const [lastPattern, setLastPattern] = useState<ExercisePattern | null>(null);
```

Add import at top:

```typescript
import type { ExercisePattern } from '@/lib/curriculum/types';
```

**Step 2: Update recordResult to track pattern**

In `recordResult` callback (around line 211), add after `setCurrentIndex((prev) => prev + 1);`:

```typescript
      // Track pattern for anti-repeat
      setLastPattern(card.exercise.pattern);
```

**Step 3: (Optional) Use anti-repeat in card ordering**

The current implementation builds cards once on mount. For full anti-repeat, we'd need dynamic selection per card. For MVP, pattern tracking enables future use.

**Step 4: Run existing session tests**

Run: `pnpm test tests/unit/hooks`
Expected: All tests PASS

**Step 5: Commit**

```bash
git add src/lib/hooks/useConceptSession.ts
git commit -m "feat(session): track lastPattern for anti-repeat logic"
```

---

### Task B3: Multi-Subconcept SRS Credit (TDD)

**Files:**
- Modify: `src/lib/hooks/useConceptSRS.ts`
- Create: `tests/unit/hooks/useConceptSRS-targets.test.ts`

**Step 1: Write failing test for multi-target credit**

Create `tests/unit/hooks/useConceptSRS-targets.test.ts`:

```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { getTargetsToCredit, getTargetsToPenalize } from '@/lib/srs/multi-target';

describe('multi-target credit logic', () => {
  describe('getTargetsToCredit', () => {
    it('returns all targets on success', () => {
      const targets = ['for', 'if', 'list-comp'];
      const result = getTargetsToCredit(targets, 'list-comp', true);
      expect(result).toEqual(['for', 'if', 'list-comp']);
    });

    it('returns primary subconcept when no targets', () => {
      const result = getTargetsToCredit(null, 'for', true);
      expect(result).toEqual(['for']);
    });

    it('returns primary subconcept when targets is empty', () => {
      const result = getTargetsToCredit([], 'for', true);
      expect(result).toEqual(['for']);
    });
  });

  describe('getTargetsToPenalize', () => {
    it('returns only primary subconcept on failure', () => {
      const targets = ['for', 'if', 'list-comp'];
      const result = getTargetsToPenalize(targets, 'list-comp', false);
      expect(result).toEqual(['list-comp']);
    });

    it('uses first target as primary when available', () => {
      const targets = ['for', 'if', 'list-comp'];
      const result = getTargetsToPenalize(targets, 'other', false);
      expect(result).toEqual(['for']);
    });

    it('returns primary subconcept when no targets', () => {
      const result = getTargetsToPenalize(null, 'for', false);
      expect(result).toEqual(['for']);
    });
  });
});
```

**Step 2: Run test to verify it fails**

Run: `pnpm test tests/unit/hooks/useConceptSRS-targets.test.ts`
Expected: FAIL - module not found

**Step 3: Create multi-target module**

Create `src/lib/srs/multi-target.ts`:

```typescript
// src/lib/srs/multi-target.ts
// Multi-subconcept credit/penalty logic for integrated exercises

/**
 * Get subconcepts to credit on success.
 * For integrated exercises with targets: credit all targets.
 * Otherwise: credit primary subconcept.
 */
export function getTargetsToCredit(
  targets: string[] | null,
  primarySubconcept: string,
  wasCorrect: boolean
): string[] {
  if (!wasCorrect) {
    return [];
  }

  if (targets && targets.length > 0) {
    return targets;
  }

  return [primarySubconcept];
}

/**
 * Get subconcepts to penalize on failure.
 * Only penalize the primary subconcept (first target or explicit subconcept).
 */
export function getTargetsToPenalize(
  targets: string[] | null,
  primarySubconcept: string,
  wasCorrect: boolean
): string[] {
  if (wasCorrect) {
    return [];
  }

  // Primary is first target if available, otherwise the explicit subconcept
  const primary = targets && targets.length > 0 ? targets[0] : primarySubconcept;
  return [primary];
}
```

**Step 4: Export from srs index**

Add to `src/lib/srs/index.ts`:

```typescript
export { getTargetsToCredit, getTargetsToPenalize } from './multi-target';
```

**Step 5: Run test to verify it passes**

Run: `pnpm test tests/unit/hooks/useConceptSRS-targets.test.ts`
Expected: All tests PASS

**Step 6: Commit**

```bash
git add src/lib/srs/multi-target.ts src/lib/srs/index.ts tests/unit/hooks/useConceptSRS-targets.test.ts
git commit -m "feat(srs): add multi-target credit/penalty logic for integrated exercises"
```

---

### Task B4: Integrate Multi-Target into SRS Hook

**Files:**
- Modify: `src/lib/hooks/useConceptSRS.ts`

**Step 1: Add import for multi-target functions**

Add at top of file:

```typescript
import { getTargetsToCredit, getTargetsToPenalize } from '@/lib/srs/multi-target';
```

**Step 2: Update recordSubconceptResult signature**

Change the function signature to accept exercise with targets:

```typescript
  const recordSubconceptResult = useCallback(
    async (
      subconceptSlug: string,
      conceptSlug: ConceptSlug,
      quality: Quality,
      exerciseSlug: string,
      wasCorrect: boolean,
      targets: string[] | null = null  // Add this parameter
    ): Promise<void> => {
```

**Step 3: Update SRS logic to handle multiple targets**

Replace the single subconcept update logic (around lines 232-255) with:

```typescript
      // Determine which subconcepts to update
      const subconceptsToUpdate = wasCorrect
        ? getTargetsToCredit(targets, subconceptSlug, wasCorrect)
        : getTargetsToPenalize(targets, subconceptSlug, wasCorrect);

      // Update each targeted subconcept
      for (const targetSlug of subconceptsToUpdate) {
        // Find existing progress for this target
        let targetProgress = dueSubconcepts.find(
          (p) => p.subconceptSlug === targetSlug
        );

        // If no progress exists, fetch or create it
        if (!targetProgress) {
          const { data: existingData, error: fetchErr } = await supabase
            .from('subconcept_progress')
            .select('*')
            .eq('user_id', user.id)
            .eq('subconcept_slug', targetSlug)
            .single();

          if (fetchErr && fetchErr.code !== 'PGRST116') {
            console.error(`Failed to fetch progress for ${targetSlug}:`, fetchErr);
            continue;
          }

          if (existingData) {
            targetProgress = mapDbToSubconceptProgress(existingData as DbSubconceptProgress);
          } else {
            // Create initial state
            targetProgress = createInitialSubconceptState(
              targetSlug,
              conceptSlug, // Use same concept for new subconcepts
              user.id
            );
          }
        }

        // Calculate new SRS state
        const result = calculateSubconceptReview(quality, targetProgress);

        // Upsert subconcept progress
        const { error: upsertError } = await supabase
          .from('subconcept_progress')
          .upsert({
            user_id: user.id,
            subconcept_slug: targetSlug,
            concept_slug: targetProgress.conceptSlug,
            phase: result.phase,
            ease_factor: result.easeFactor,
            interval: result.interval,
            next_review: result.nextReview.toISOString(),
            last_reviewed: result.lastReviewed.toISOString(),
            updated_at: new Date().toISOString(),
          })
          .select()
          .single();

        if (upsertError) {
          console.error(`Failed to update progress for ${targetSlug}:`, upsertError);
        }
      }
```

**Step 4: Update UseConceptSRSReturn interface**

Update the type signature in the interface (around line 55):

```typescript
  recordSubconceptResult: (
    subconceptSlug: string,
    conceptSlug: ConceptSlug,
    quality: Quality,
    exerciseSlug: string,
    wasCorrect: boolean,
    targets?: string[] | null
  ) => Promise<void>;
```

**Step 5: Run typecheck**

Run: `pnpm typecheck`
Expected: Errors in useConceptSession.ts (needs to pass targets)

**Step 6: Update useConceptSession to pass targets**

In `src/lib/hooks/useConceptSession.ts`, update the `recordResult` callback (around line 234):

```typescript
        await recordSubconceptResult(
          card.subconceptProgress.subconceptSlug,
          card.subconceptProgress.conceptSlug,
          quality,
          card.exercise.slug,
          isCorrect,
          card.exercise.targets  // Add targets parameter
        );
```

**Step 7: Run typecheck and tests**

Run: `pnpm typecheck && pnpm test tests/unit/hooks`
Expected: All PASS

**Step 8: Commit**

```bash
git add src/lib/hooks/useConceptSRS.ts src/lib/hooks/useConceptSession.ts
git commit -m "feat(srs): integrate multi-target credit into SRS hooks"
```

---

## Part C: Curriculum Graph Update

### Task C1: Add New Subconcepts to python.json

**Files:**
- Modify: `src/lib/curriculum/python.json`

**Step 1: Update control-flow subconcepts**

Change:
```json
"subconcepts": ["conditionals", "for", "while", "iteration"]
```

To:
```json
"subconcepts": ["conditionals", "for", "while", "iteration", "zip", "reversed", "sorted", "any-all"]
```

**Step 2: Update collections subconcepts**

Change:
```json
"subconcepts": ["lists", "tuples", "dicts", "sets", "unpacking"]
```

To:
```json
"subconcepts": ["lists", "tuples", "dicts", "sets", "unpacking", "mutability"]
```

**Step 3: Update numbers-booleans subconcepts**

Change:
```json
"subconcepts": ["integers", "floats", "booleans", "conversion"]
```

To:
```json
"subconcepts": ["integers", "floats", "booleans", "conversion", "truthiness", "comparisons"]
```

**Step 4: Update functions subconcepts**

Change:
```json
"subconcepts": ["basics", "arguments", "scope", "lambda", "typehints"]
```

To:
```json
"subconcepts": ["basics", "arguments", "defaults", "args-kwargs", "scope", "lambda", "typehints"]
```

**Step 5: Update modules-files subconcepts**

Change:
```json
"subconcepts": ["imports", "reading", "writing", "context"]
```

To:
```json
"subconcepts": ["imports", "reading", "writing", "context", "pathlib", "main-guard"]
```

**Step 6: Commit**

```bash
git add src/lib/curriculum/python.json
git commit -m "feat(curriculum): add new subconcepts for Phase 2.5 coverage"
```

---

## Part D: Content Backfill - Add Objective to Existing Exercises

### Task D1: Backfill objectives to loops.yaml

**Files:**
- Modify: `exercises/python/loops.yaml`

**Step 1: Add objective to each exercise**

For each exercise in the file, add an `objective` field after `pattern`. Examples:

```yaml
- slug: for-loop-range
  # ... existing fields ...
  pattern: iteration
  objective: "Write a basic for loop using range() to iterate over numbers"
  prompt: Write a for loop that prints numbers 0 through 4

- slug: enumerate-loop
  # ... existing fields ...
  pattern: iteration
  objective: "Use enumerate() to access both index and value while iterating"
  prompt: Loop over items with both index and value using enumerate
```

**Step 2: Validate changes**

Run: `pnpm validate:exercises`
Expected: Validation errors for other files (no objective) - loops.yaml should pass

**Step 3: Commit**

```bash
git add exercises/python/loops.yaml
git commit -m "content(exercises): add objectives to loops.yaml exercises"
```

---

### Task D2-D12: Repeat for remaining YAML files

Repeat the same process for each file:
- `exercises/python/basics.yaml`
- `exercises/python/strings.yaml`
- `exercises/python/operators.yaml`
- `exercises/python/lists.yaml`
- `exercises/python/dictionaries.yaml`
- `exercises/python/functions.yaml`
- `exercises/python/classes.yaml`
- `exercises/python/comprehensions.yaml`
- `exercises/python/exceptions.yaml`
- `exercises/python/collections.yaml`
- `exercises/python/foundations.yaml`
- `exercises/python/modules-files.yaml`

Each commit follows the pattern:
```bash
git add exercises/python/<file>.yaml
git commit -m "content(exercises): add objectives to <file>.yaml exercises"
```

---

### Task D13: Add targets to integrated exercises

**Files:**
- Modify: All `exercises/python/*.yaml` files with `level: integrated`

**Step 1: Find integrated exercises**

Run: `grep -l "level: integrated" exercises/python/*.yaml`

**Step 2: Add targets to each integrated exercise**

For each exercise with `level: integrated`, add a `targets` array:

```yaml
- slug: list-comp-with-filter
  level: integrated
  subconcept: list-comp
  targets: ["list-comp", "for", "conditionals"]  # Add this
  # ... rest of exercise
```

**Step 3: Validate all exercises**

Run: `pnpm validate:exercises`
Expected: All exercises pass validation

**Step 4: Import to database**

Run: `pnpm db:import-exercises`
Expected: All 171+ exercises imported successfully

**Step 5: Commit**

```bash
git add exercises/python/*.yaml
git commit -m "content(exercises): add targets to integrated exercises"
```

---

## Part E: New Content Creation

### Task E1-E8: Create New Exercise Files

For each new subconcept, create exercises following this pattern:

**Example: zip subconcept**

Add to `exercises/python/loops.yaml`:

```yaml
# --- zip() iteration ---
- slug: zip-two-lists
  title: Zip Two Lists
  difficulty: 1
  concept: control-flow
  subconcept: zip
  level: intro
  prereqs: [for]
  type: write
  pattern: iteration
  objective: "Use zip() to iterate over two lists simultaneously"
  prompt: Use zip to iterate over names and ages lists together
  expected_answer: "for name, age in zip(names, ages):"
  hints:
    - zip() combines iterables
    - Use tuple unpacking
  tags: [zip, iteration]

- slug: zip-three-lists
  title: Zip Three Lists
  difficulty: 2
  concept: control-flow
  subconcept: zip
  level: practice
  prereqs: [zip]
  type: write
  pattern: iteration
  objective: "Use zip() with three or more iterables"
  prompt: Zip names, ages, and cities lists
  expected_answer: "for name, age, city in zip(names, ages, cities):"
  hints:
    - zip() accepts any number of iterables
  tags: [zip, iteration, multiple]
```

Create similar exercises for:
- `reversed` (2-3 exercises)
- `sorted` with key (3-4 exercises)
- `any-all` (4-5 exercises)
- `mutability` (8-10 exercises)
- `truthiness` (5-6 exercises)
- `comparisons` (5-6 exercises)
- `defaults` (4-5 exercises)
- `args-kwargs` (4-5 exercises)
- `pathlib` (4-5 exercises)
- `main-guard` (2-3 exercises)

**Commit after each subconcept batch:**

```bash
git add exercises/python/*.yaml
git commit -m "content(exercises): add <subconcept> exercises"
```

---

## Part F: Cleanup & Documentation

### Task F1: Run Full Test Suite

**Step 1: Run all tests**

Run: `pnpm test`
Expected: All tests PASS

**Step 2: Run typecheck**

Run: `pnpm typecheck`
Expected: PASS

**Step 3: Run lint**

Run: `pnpm lint`
Expected: PASS (or fix any issues)

---

### Task F2: Update CLAUDE.md

**Files:**
- Modify: `CLAUDE.md`

Add to Phase 2 section:

```markdown
## Phase 2.5: Curriculum Enhancement

**New Exercise Fields:**
- `objective` (required): Learning target, 10-150 chars starting with verb
- `targets` (conditional): Array of subconcepts for integrated exercises

**Algorithm Improvements:**
- Anti-repeat pattern: Sessions avoid showing same pattern consecutively
- Multi-subconcept SRS: Integrated exercises credit all `targets` on success

**New Subconcepts Added:**
- control-flow: zip, reversed, sorted, any-all
- collections: mutability
- numbers-booleans: truthiness, comparisons
- functions: defaults, args-kwargs
- modules-files: pathlib, main-guard
```

**Commit:**

```bash
git add CLAUDE.md
git commit -m "docs: update CLAUDE.md with Phase 2.5 changes"
```

---

### Task F3: Final Validation

**Step 1: Validate all exercises**

Run: `pnpm validate:exercises`
Expected: All exercises valid

**Step 2: Import all exercises**

Run: `pnpm db:import-exercises`
Expected: All exercises imported

**Step 3: Test the app**

Run: `pnpm dev`
- Navigate to /practice
- Verify exercises load
- Verify SRS works
- Verify variety in patterns

**Step 4: Final commit**

```bash
git add -A
git commit -m "chore: Phase 2.5 complete - curriculum enhancement"
```

---

## Execution Checklist

### Part A: Schema & Infrastructure
- [ ] A1: Add objective and targets to JSON Schema
- [ ] A2: Update TypeScript types
- [ ] A3: Create database migration
- [ ] A4: Update exercise mapper (TDD)
- [ ] A5: Update import script

### Part B: Algorithm Changes
- [ ] B1: Create anti-repeat selection module (TDD)
- [ ] B2: Integrate anti-repeat into session hook
- [ ] B3: Create multi-target credit module (TDD)
- [ ] B4: Integrate multi-target into SRS hook

### Part C: Curriculum Graph
- [ ] C1: Add new subconcepts to python.json

### Part D: Content Backfill
- [ ] D1-D12: Add objective to all existing exercises
- [ ] D13: Add targets to integrated exercises

### Part E: New Content
- [ ] E1-E8: Create exercises for new subconcepts (~65-85 exercises)

### Part F: Cleanup
- [ ] F1: Run full test suite
- [ ] F2: Update CLAUDE.md
- [ ] F3: Final validation

---

**Total Estimated Tasks:** 25+ tasks
**Test Coverage:** ~15 new tests (TDD for algorithm changes)
**New Exercises:** ~65-85

---

Plan complete and saved to `docs/plans/2026-01-05-phase2.5-implementation-plan.md`.

**Two execution options:**

**1. Subagent-Driven (this session)** - I dispatch fresh subagent per task, review between tasks, fast iteration

**2. Parallel Session (separate)** - Open new session with executing-plans, batch execution with checkpoints

**Which approach?**
