{
  "language": "python",
  "version": "2.0.0",
  "concepts": [
    {
      "slug": "foundations",
      "name": "Foundations",
      "description": "Variables, operators, expressions, basic I/O, and imports",
      "prereqs": [],
      "subconcepts": ["variables", "operators", "expressions", "io", "imports-basic"]
    },
    {
      "slug": "strings",
      "name": "Strings",
      "description": "String manipulation, formatting, and f-strings",
      "prereqs": ["foundations"],
      "subconcepts": ["basics", "indexing", "slicing", "string-methods", "fstrings"]
    },
    {
      "slug": "numbers-booleans",
      "name": "Numbers & Booleans",
      "description": "Numeric types, boolean logic, comparisons, and type conversion",
      "prereqs": ["foundations"],
      "subconcepts": ["integers", "floats", "booleans", "conversion", "truthiness", "comparisons", "identity"]
    },
    {
      "slug": "conditionals",
      "name": "Conditionals",
      "description": "Branching logic with if, elif, else, and ternary expressions",
      "prereqs": ["numbers-booleans"],
      "subconcepts": ["if-else", "elif-chains", "ternary", "match-case"]
    },
    {
      "slug": "collections",
      "name": "Collections",
      "description": "Lists, tuples, dictionaries, and sets",
      "prereqs": ["strings", "numbers-booleans"],
      "subconcepts": ["lists", "tuples", "dicts", "sets", "unpacking", "mutability", "dict-iteration"]
    },
    {
      "slug": "loops",
      "name": "Loops",
      "description": "For loops, while loops, and iteration patterns",
      "prereqs": ["conditionals", "collections"],
      "subconcepts": ["for", "while", "range", "iteration", "zip", "reversed", "sorted", "any-all", "break-continue"]
    },
    {
      "slug": "functions",
      "name": "Functions",
      "description": "Function definitions, parameters, and scope",
      "prereqs": ["loops"],
      "subconcepts": ["fn-basics", "arguments", "defaults", "args-kwargs", "scope", "lambda", "typehints", "decorators"]
    },
    {
      "slug": "comprehensions",
      "name": "Comprehensions & Generators",
      "description": "List, dict, set comprehensions, generator expressions, and generator functions",
      "prereqs": ["loops"],
      "subconcepts": ["list-comp", "dict-comp", "set-comp", "generator-exp", "generators"]
    },
    {
      "slug": "error-handling",
      "name": "Error Handling",
      "description": "Exception handling and error management",
      "prereqs": ["conditionals", "functions"],
      "subconcepts": ["try-except", "finally", "raising"]
    },
    {
      "slug": "oop",
      "name": "OOP",
      "description": "Classes, objects, and inheritance",
      "prereqs": ["functions"],
      "subconcepts": ["classes", "methods", "inheritance", "classmethod", "properties", "dataclasses"]
    },
    {
      "slug": "modules-files",
      "name": "Modules & Files",
      "description": "Advanced imports, file I/O, and context managers",
      "prereqs": ["error-handling", "oop"],
      "subconcepts": ["imports", "reading", "writing", "context", "pathlib", "main-guard"]
    }
  ],
  "subconcepts": {
    "variables": {
      "name": "Variables",
      "concept": "foundations",
      "prereqs": [],
      "teaching": {
        "explanation": "Variables store data using the assignment operator (=). Use descriptive names like `user_count` or `total_price`.",
        "exampleCode": "greeting = \"Welcome to Python!\"",
        "exampleSlug": "assign-variable"
      }
    },
    "operators": {
      "name": "Operators",
      "concept": "foundations",
      "prereqs": ["variables"],
      "teaching": {
        "explanation": "Python supports arithmetic (+, -, *, /), comparison (==, <, >), and logical (and, or, not) operators.",
        "exampleCode": "result = 10 + 7",
        "exampleSlug": "operator-addition-fill"
      }
    },
    "expressions": {
      "name": "Expressions",
      "concept": "foundations",
      "prereqs": ["operators"],
      "teaching": {
        "explanation": "Expressions combine values and operators to produce results. Use `and`, `or`, `not` for boolean logic.",
        "exampleCode": "is_valid = x > 0 and y > 0",
        "exampleSlug": "boolean-and"
      }
    },
    "io": {
      "name": "Input/Output",
      "concept": "foundations",
      "prereqs": ["variables"],
      "teaching": {
        "explanation": "Use `print()` to display output and `input()` to get user input. Input always returns a string.",
        "exampleCode": "print(\"Welcome to Python!\")",
        "exampleSlug": "print-string"
      }
    },
    "imports-basic": {
      "name": "Basic Imports",
      "concept": "foundations",
      "prereqs": ["variables"],
      "teaching": {
        "explanation": "Use `import module` to access built-in modules like math, random, datetime. Use `from module import name` for specific items.",
        "exampleCode": "import math\nradius = 5\narea = math.pi * radius ** 2",
        "exampleSlug": "import-math"
      }
    },
    "basics": {
      "name": "String Basics",
      "concept": "strings",
      "prereqs": ["variables"],
      "teaching": {
        "explanation": "Strings are sequences of characters. Create with quotes, concatenate with +, repeat with *, get length with len().",
        "exampleCode": "full_name = first + \" \" + last",
        "exampleSlug": "string-concatenate"
      }
    },
    "indexing": {
      "name": "String Indexing",
      "concept": "strings",
      "prereqs": ["basics"],
      "teaching": {
        "explanation": "Access characters by position with `s[i]`. Index 0 is first, -1 is last. Raises IndexError if out of range.",
        "exampleCode": "last_char = word[-1]",
        "exampleSlug": "string-index-dynamic"
      }
    },
    "slicing": {
      "name": "String Slicing",
      "concept": "strings",
      "prereqs": ["indexing"],
      "teaching": {
        "explanation": "Extract substrings with `s[start:end:step]`. Omit start/end for beginning/end. Use [::-1] to reverse.",
        "exampleCode": "middle = text[2:5]",
        "exampleSlug": "string-slice-start",
        "pitfall": {
          "mistake": "Expecting s[2:5] to include index 5",
          "why": "Python slices are half-open: [start, end). Index 5 is excluded. Think of it as 'up to but not including'.",
          "fix": "Use s[2:6] to include index 5, or remember end = desired_last_index + 1"
        }
      }
    },
    "string-methods": {
      "name": "String Methods",
      "concept": "strings",
      "prereqs": ["basics"],
      "teaching": {
        "explanation": "Strings have methods like upper(), lower(), strip(), split(), replace(), find(). They return new strings.",
        "exampleCode": "clean = text.strip().lower()",
        "exampleSlug": "string-upper"
      }
    },
    "fstrings": {
      "name": "F-Strings",
      "concept": "strings",
      "prereqs": ["basics"],
      "teaching": {
        "explanation": "F-strings embed expressions in strings: `f\"Hello, {name}!\"`. Use format specs like `{x:.2f}` for precision.",
        "exampleCode": "message = f\"{user} has {points} points\"",
        "exampleSlug": "f-string-basic",
        "pitfall": {
          "mistake": "Using + for string concatenation: 'Hello ' + name + '!'",
          "why": "Concatenation is slower, harder to read, and error-prone with mixed types.",
          "fix": "Use f-strings for any string with variables: f'Hello {name}!'"
        }
      }
    },
    "integers": {
      "name": "Integers",
      "concept": "numbers-booleans",
      "prereqs": ["variables"],
      "teaching": {
        "explanation": "Integers are whole numbers with unlimited precision. Use //, %, ** for floor division, modulo, exponentiation.",
        "exampleCode": "remainder = 17 % 5  # Result: 2",
        "exampleSlug": "int-floor-div-fill"
      }
    },
    "floats": {
      "name": "Floats",
      "concept": "numbers-booleans",
      "prereqs": ["integers"],
      "teaching": {
        "explanation": "Floats represent decimal numbers. Use round() for precision. Be aware of floating-point inaccuracy.",
        "exampleCode": "price = round(19.995, 2)  # Result: 20.0",
        "exampleSlug": "float-round-fill"
      }
    },
    "booleans": {
      "name": "Booleans",
      "concept": "numbers-booleans",
      "prereqs": ["variables"],
      "teaching": {
        "explanation": "Booleans are True or False. Combine with `and`, `or`, `not`. Use in conditionals and while loops.",
        "exampleCode": "is_ready = has_data and not is_loading",
        "exampleSlug": "boolean-and"
      }
    },
    "conversion": {
      "name": "Type Conversion",
      "concept": "numbers-booleans",
      "prereqs": ["integers", "floats"],
      "teaching": {
        "explanation": "Convert types with int(), float(), str(), bool(). Use type() to check a value's type.",
        "exampleCode": "count = int(\"42\")",
        "exampleSlug": "convert-int-fill"
      }
    },
    "truthiness": {
      "name": "Truthiness",
      "concept": "numbers-booleans",
      "prereqs": ["booleans"],
      "teaching": {
        "explanation": "Falsy values: False, None, 0, \"\", [], {}, set(). Everything else is truthy. Use `if items:` not `if len(items) > 0:`.",
        "exampleCode": "if items:  # True if items is non-empty",
        "exampleSlug": "truthiness-predict-empty",
        "pitfall": {
          "mistake": "Writing `if len(items) > 0:` or `if items == []:`",
          "why": "Python's truthiness makes this verbose and slower. Empty collections are already falsy.",
          "fix": "Use `if items:` for non-empty, `if not items:` for empty"
        }
      }
    },
    "comparisons": {
      "name": "Comparisons",
      "concept": "numbers-booleans",
      "prereqs": ["booleans"],
      "teaching": {
        "explanation": "Compare values with ==, !=, <, >, <=, >=. Chain comparisons: `0 < x < 10`. Use `in` for membership tests.",
        "exampleCode": "is_valid = 0 <= score <= 100",
        "exampleSlug": "comparison-chain"
      }
    },
    "identity": {
      "name": "Identity",
      "concept": "numbers-booleans",
      "prereqs": ["comparisons"],
      "teaching": {
        "explanation": "Use `is` for identity (same object), `==` for equality (same value). Always use `is None`, never `== None`.",
        "exampleCode": "if result is None:\n    print(\"No result found\")",
        "exampleSlug": "identity-is-none",
        "pitfall": {
          "mistake": "Using == to compare with None",
          "why": "== checks value equality and can be overridden by __eq__. None is a singleton, so identity (is) is faster and more correct.",
          "fix": "Always use `x is None` or `x is not None`",
          "productionImpact": "Objects with custom __eq__ return unexpected results. A NaN-like object where x == None returns True causes silent bugs."
        }
      }
    },
    "if-else": {
      "name": "If-Else",
      "concept": "conditionals",
      "prereqs": ["comparisons"],
      "teaching": {
        "explanation": "Use `if condition:` to branch. Add `else:` for the alternative path. Indent the code block 4 spaces.",
        "exampleCode": "if temperature > 30:\n    print(\"Hot day!\")\nelse:\n    print(\"Nice weather\")",
        "exampleSlug": "if-else-basic"
      }
    },
    "elif-chains": {
      "name": "Elif Chains",
      "concept": "conditionals",
      "prereqs": ["if-else"],
      "teaching": {
        "explanation": "Use `elif` for multiple conditions. Python checks top-to-bottom, stops at first True. End with `else` as fallback.",
        "exampleCode": "if score >= 90:\n    grade = 'A'\nelif score >= 80:\n    grade = 'B'\nelse:\n    grade = 'C'",
        "exampleSlug": "elif-grade"
      }
    },
    "ternary": {
      "name": "Ternary Expressions",
      "concept": "conditionals",
      "prereqs": ["if-else"],
      "teaching": {
        "explanation": "Use `value_if_true if condition else value_if_false` for inline conditionals. Keep it simple - one line only.",
        "exampleCode": "status = \"adult\" if age >= 18 else \"minor\"",
        "exampleSlug": "ternary-basic"
      }
    },
    "match-case": {
      "name": "Match-Case",
      "concept": "conditionals",
      "prereqs": ["elif-chains"],
      "teaching": {
        "explanation": "Python 3.10+ structural pattern matching. Use `match value:` with `case pattern:` blocks. `case _:` is the wildcard.",
        "exampleCode": "match command:\n    case \"quit\":\n        exit()\n    case \"help\":\n        show_help()\n    case _:\n        print(\"Unknown\")",
        "exampleSlug": "match-case-basic"
      }
    },
    "lists": {
      "name": "Lists",
      "concept": "collections",
      "prereqs": ["variables"],
      "teaching": {
        "explanation": "Lists are mutable sequences: `[1, 2, 3]`. Use append(), extend(), pop(). Access by index, slice like strings.",
        "exampleCode": "colors = [\"red\", \"green\", \"blue\"]",
        "exampleSlug": "list-create-empty"
      }
    },
    "tuples": {
      "name": "Tuples",
      "concept": "collections",
      "prereqs": ["lists"],
      "teaching": {
        "explanation": "Tuples are immutable sequences: `(1, 2, 3)`. Use for fixed data, function returns, dict keys. Single item: `(x,)`.",
        "exampleCode": "point = (10, 20)",
        "exampleSlug": "tuple-create"
      }
    },
    "dicts": {
      "name": "Dictionaries",
      "concept": "collections",
      "prereqs": ["lists"],
      "teaching": {
        "explanation": "Dicts map keys to values: `{\"name\": \"Alice\"}`. Use get() for safe access, keys(), values(), items() for iteration.",
        "exampleCode": "user = {\"name\": \"Alice\", \"age\": 30}",
        "exampleSlug": "dict-create-empty"
      }
    },
    "sets": {
      "name": "Sets",
      "concept": "collections",
      "prereqs": ["lists"],
      "teaching": {
        "explanation": "Sets store unique values: `{1, 2, 3}`. Use add(), remove(), |, &, - for union, intersection, difference.",
        "exampleCode": "unique = {1, 2, 3, 2, 1}  # {1, 2, 3}",
        "exampleSlug": "set-create"
      }
    },
    "unpacking": {
      "name": "Unpacking",
      "concept": "collections",
      "prereqs": ["lists", "tuples"],
      "teaching": {
        "explanation": "Unpack sequences: `a, b, c = [1, 2, 3]`. Use * for rest: `first, *rest = items`. ** unpacks dict kwargs.",
        "exampleCode": "first, *rest = [1, 2, 3, 4]",
        "exampleSlug": "star-unpack"
      }
    },
    "mutability": {
      "name": "Mutability",
      "concept": "collections",
      "prereqs": ["lists", "dicts"],
      "teaching": {
        "explanation": "Lists, dicts, sets are mutable (can change). Tuples, strings are immutable. Use copy() to avoid aliasing bugs.",
        "exampleCode": "copy = original[:]  # Shallow copy to avoid aliasing",
        "exampleSlug": "list-aliasing",
        "pitfall": {
          "mistake": "Using mutable default arguments like `def f(items=[])`",
          "why": "Default arguments are evaluated once at function definition. All calls share the same list object.",
          "fix": "Use `def f(items=None):` then `items = items or []` inside the function",
          "productionImpact": "In web servers, causes request data to leak between users. One user's cart items appear in another's session."
        }
      }
    },
    "dict-iteration": {
      "name": "Dict Iteration",
      "concept": "collections",
      "prereqs": ["dicts"],
      "teaching": {
        "explanation": "Iterate dicts with .keys(), .values(), .items(). Default iteration gives keys. Use items() for key-value pairs.",
        "exampleCode": "for key, value in user.items():\n    print(f\"{key}: {value}\")",
        "exampleSlug": "dict-items-loop"
      }
    },
    "for": {
      "name": "For Loops",
      "concept": "loops",
      "prereqs": ["lists"],
      "teaching": {
        "explanation": "For loops iterate over sequences. Use `for item in sequence:` to process each element. Use range() for numbers.",
        "exampleCode": "for product in cart:\n    print(product.name)",
        "exampleSlug": "for-loop-list"
      }
    },
    "while": {
      "name": "While Loops",
      "concept": "loops",
      "prereqs": ["if-else"],
      "teaching": {
        "explanation": "While loops run until condition is False. Use for unknown iteration counts. Watch for infinite loops!",
        "exampleCode": "while retry_count < max_retries:\n    result = try_connect()\n    retry_count += 1",
        "exampleSlug": "while-loop"
      }
    },
    "range": {
      "name": "Range",
      "concept": "loops",
      "prereqs": ["for"],
      "teaching": {
        "explanation": "range(stop), range(start, stop), range(start, stop, step). Returns iterator, not list. Use list(range()) if needed.",
        "exampleCode": "for page_num in range(1, total_pages + 1):\n    fetch_page(page_num)",
        "exampleSlug": "range-start-stop"
      }
    },
    "iteration": {
      "name": "Iteration Patterns",
      "concept": "loops",
      "prereqs": ["for"],
      "teaching": {
        "explanation": "Use enumerate() for index+value. Prefer iteration over index access. Avoid range(len(x)) - use enumerate instead.",
        "exampleCode": "for index, user in enumerate(users):\n    print(f\"{index + 1}. {user.name}\")",
        "exampleSlug": "enumerate-loop",
        "pitfall": {
          "mistake": "Using `for i in range(len(items)):` to access items[i]",
          "why": "This is verbose, error-prone, and unpythonic. Direct iteration is clearer and faster.",
          "fix": "Use `for item in items:` or `for i, item in enumerate(items):`"
        }
      }
    },
    "zip": {
      "name": "Zip",
      "concept": "loops",
      "prereqs": ["for"],
      "teaching": {
        "explanation": "zip() pairs elements from multiple iterables: `for a, b in zip(list1, list2):`. Stops at shortest iterable.",
        "exampleCode": "for name, email in zip(names, emails):\n    send_invite(name, email)",
        "exampleSlug": "zip-two-lists"
      }
    },
    "reversed": {
      "name": "Reversed",
      "concept": "loops",
      "prereqs": ["for"],
      "teaching": {
        "explanation": "reversed() iterates backwards without modifying the original. Use `for item in reversed(items):` for reverse order.",
        "exampleCode": "for transaction in reversed(history):\n    print(transaction)",
        "exampleSlug": "reversed-list"
      }
    },
    "sorted": {
      "name": "Sorted",
      "concept": "loops",
      "prereqs": ["for"],
      "teaching": {
        "explanation": "sorted() returns a new sorted list. Use key= for custom sorting, reverse=True for descending order.",
        "exampleCode": "for product in sorted(products, key=lambda p: p.price):\n    display(product)",
        "exampleSlug": "sorted-list"
      }
    },
    "any-all": {
      "name": "Any/All",
      "concept": "loops",
      "prereqs": ["if-else", "for"],
      "teaching": {
        "explanation": "any() returns True if any element is truthy. all() returns True if all are truthy. Use with generator expressions.",
        "exampleCode": "all_valid = all(item.is_valid for item in cart_items)",
        "exampleSlug": "any-basic"
      }
    },
    "break-continue": {
      "name": "Break & Continue",
      "concept": "loops",
      "prereqs": ["for", "while"],
      "teaching": {
        "explanation": "break exits the loop immediately. continue skips to next iteration. Use sparingly - prefer conditions in loop header.",
        "exampleCode": "for user in users:\n    if user.is_banned:\n        continue\n    send_notification(user)",
        "exampleSlug": "break-loop"
      }
    },
    "fn-basics": {
      "name": "Function Basics",
      "concept": "functions",
      "prereqs": [],
      "teaching": {
        "explanation": "Functions are defined with `def name(params):`. They organize reusable code. Use `return` to send back values.",
        "exampleCode": "def square(n):\\n    return n ** 2",
        "exampleSlug": "define-function"
      }
    },
    "arguments": {
      "name": "Function Arguments",
      "concept": "functions",
      "prereqs": ["fn-basics"],
      "teaching": {
        "explanation": "Functions take positional and keyword arguments. Use name=value for keyword args. Order: positional, *args, keyword, **kwargs.",
        "exampleCode": "def greet(name, greeting=\"Hello\"):\\n    return f\"{greeting}, {name}!\"",
        "exampleSlug": "kwargs-function"
      }
    },
    "defaults": {
      "name": "Default Parameters",
      "concept": "functions",
      "prereqs": ["fn-basics"],
      "teaching": {
        "explanation": "Set defaults with `def f(x=10):`. Never use mutable defaults like []. Use None and create inside the function.",
        "exampleCode": "def connect(host, port=8080, timeout=30):\\n    ...",
        "exampleSlug": "default-param-simple"
      }
    },
    "args-kwargs": {
      "name": "Args & Kwargs",
      "concept": "functions",
      "prereqs": ["arguments"],
      "teaching": {
        "explanation": "*args captures variable positional args as tuple. **kwargs captures keyword args as dict. Use to forward arguments.",
        "exampleCode": "def log(*messages, **options):\\n    for msg in messages:\\n        print(msg)",
        "exampleSlug": "args-intro"
      }
    },
    "scope": {
      "name": "Scope",
      "concept": "functions",
      "prereqs": ["fn-basics"],
      "teaching": {
        "explanation": "Variables have local, enclosing, global, built-in scope (LEGB). Use `global` or `nonlocal` to modify outer variables.",
        "exampleCode": "def increment():\\n    global counter\\n    counter += 1",
        "exampleSlug": "global-keyword",
        "pitfall": {
          "mistake": "Creating closures in loops: `[lambda: i for i in range(3)]` all return 2",
          "why": "Closures capture the variable reference, not the value. By loop end, i equals 2 for all lambdas.",
          "fix": "Capture the value with a default argument: `lambda i=i: i`",
          "productionImpact": "Event handlers all fire with wrong data. UI buttons all trigger the last item's action instead of their own."
        }
      }
    },
    "lambda": {
      "name": "Lambda Functions",
      "concept": "functions",
      "prereqs": ["fn-basics"],
      "teaching": {
        "explanation": "Lambda creates anonymous functions: `lambda x: x * 2`. Use for simple operations, especially with map, filter, sorted key.",
        "exampleCode": "square = lambda n: n ** 2",
        "exampleSlug": "lambda-simple"
      }
    },
    "typehints": {
      "name": "Type Hints",
      "concept": "functions",
      "prereqs": ["fn-basics"],
      "teaching": {
        "explanation": "Add type hints: `def greet(name: str) -> str:`. Use list[int], Optional[str], Callable. Checked by mypy, not at runtime.",
        "exampleCode": "def add(a: int, b: int) -> int:\\n    return a + b",
        "exampleSlug": "typehint-param"
      }
    },
    "decorators": {
      "name": "Decorators",
      "concept": "functions",
      "prereqs": ["lambda", "scope"],
      "teaching": {
        "explanation": "Decorators wrap functions to add behavior. Use @decorator syntax. Common: @property, @staticmethod, @functools.cache.",
        "exampleCode": "from functools import cache\\n\\n@cache\\ndef fib(n):\\n    return n if n < 2 else fib(n-1) + fib(n-2)",
        "exampleSlug": "decorator-cache",
        "pitfall": {
          "mistake": "Forgetting @functools.wraps when writing custom decorators",
          "why": "Without @wraps, the decorated function loses its __name__, __doc__, and signature.",
          "fix": "Always use @functools.wraps(func) in your wrapper function",
          "productionImpact": "Tracebacks show 'wrapper' instead of real function names. Debugging production errors becomes a nightmare."
        }
      }
    },
    "list-comp": {
      "name": "List Comprehensions",
      "concept": "comprehensions",
      "prereqs": ["for", "lists"],
      "teaching": {
        "explanation": "Create lists with `[expr for x in iterable if condition]`. More readable than map/filter for simple transformations.",
        "exampleCode": "doubled = [n * 2 for n in numbers]",
        "exampleSlug": "list-comp-basic"
      }
    },
    "dict-comp": {
      "name": "Dict Comprehensions",
      "concept": "comprehensions",
      "prereqs": ["list-comp", "dicts"],
      "teaching": {
        "explanation": "Create dicts with `{key: value for x in iterable}`. Use zip() to combine two lists into a dict.",
        "exampleCode": "lengths = {word: len(word) for word in words}",
        "exampleSlug": "dict-comp-basic"
      }
    },
    "set-comp": {
      "name": "Set Comprehensions",
      "concept": "comprehensions",
      "prereqs": ["list-comp", "sets"],
      "teaching": {
        "explanation": "Create sets with `{expr for x in iterable}`. Automatically deduplicates values. Use for unique transformations.",
        "exampleCode": "initials = {name[0] for name in names}",
        "exampleSlug": "set-comp-basic"
      }
    },
    "generator-exp": {
      "name": "Generator Expressions",
      "concept": "comprehensions",
      "prereqs": ["list-comp"],
      "teaching": {
        "explanation": "Use `(expr for x in iterable)` for memory-efficient iteration. Values computed on demand, not stored in memory.",
        "exampleCode": "total = sum(n ** 2 for n in range(1000))",
        "exampleSlug": "generator-exp-basic"
      }
    },
    "generators": {
      "name": "Generator Functions",
      "concept": "comprehensions",
      "prereqs": ["generator-exp", "fn-basics"],
      "teaching": {
        "explanation": "Use `yield` to create generators that produce values one at a time. Each call to next() resumes execution until the next yield.",
        "exampleCode": "def countdown(n):\n    while n > 0:\n        yield n\n        n -= 1\n\nfor num in countdown(3):\n    print(num)  # 3, 2, 1",
        "pitfall": {
          "mistake": "Calling a generator function returns a generator object, not the values directly",
          "why": "Generator functions don't execute until iterated. countdown(3) returns a generator, not [3, 2, 1].",
          "fix": "Iterate with for loop, or use list(countdown(3)) to collect all values"
        }
      }
    },
    "try-except": {
      "name": "Try-Except",
      "concept": "error-handling",
      "prereqs": ["if-else"],
      "teaching": {
        "explanation": "Wrap risky code in try/except. Catch specific exceptions like ValueError. Use `as e` to access exception details.",
        "exampleCode": "try:\n    price = float(user_input)\nexcept ValueError:\n    print(\"Please enter a valid price\")",
        "exampleSlug": "try-except-basic"
      }
    },
    "finally": {
      "name": "Finally",
      "concept": "error-handling",
      "prereqs": ["try-except"],
      "teaching": {
        "explanation": "finally: always runs, even if exception occurs or return is called. Use for cleanup like closing files.",
        "exampleCode": "try:\\n    f = open(path)\\n    data = f.read()\\nfinally:\\n    f.close()",
        "exampleSlug": "finally-basic"
      }
    },
    "raising": {
      "name": "Raising Exceptions",
      "concept": "error-handling",
      "prereqs": ["try-except"],
      "teaching": {
        "explanation": "Use `raise ValueError(\"message\")` to signal errors. Re-raise with bare `raise`. Create custom exceptions by subclassing.",
        "exampleCode": "if age < 0:\\n    raise ValueError(\"Age must be positive\")",
        "exampleSlug": "raise-exception"
      }
    },
    "classes": {
      "name": "Classes",
      "concept": "oop",
      "prereqs": ["fn-basics"],
      "teaching": {
        "explanation": "Classes define object blueprints. Use __init__ for setup, self for instance access. Create instances with ClassName().",
        "exampleCode": "class Product:\n    def __init__(self, name, price):\n        self.name = name\n        self.price = price",
        "exampleSlug": "define-class"
      }
    },
    "methods": {
      "name": "Methods",
      "concept": "oop",
      "prereqs": ["classes"],
      "teaching": {
        "explanation": "Methods are functions on classes. Instance methods take self first. Use __init__ for constructor, __str__ for string representation.",
        "exampleCode": "def bark(self):\\n    return f\"{self.name} says woof!\"",
        "exampleSlug": "init-method"
      }
    },
    "inheritance": {
      "name": "Inheritance",
      "concept": "oop",
      "prereqs": ["classes", "methods"],
      "teaching": {
        "explanation": "Subclass with `class Child(Parent):`. Use super().__init__() to call parent constructor. Override methods to specialize.",
        "exampleCode": "class Cat(Animal):\\n    def speak(self):\\n        return \"meow\"",
        "exampleSlug": "inheritance-basic"
      }
    },
    "classmethod": {
      "name": "Class Methods",
      "concept": "oop",
      "prereqs": ["methods"],
      "teaching": {
        "explanation": "Use @classmethod for methods that operate on the class, not instances. First parameter is cls. Often used for alternative constructors.",
        "exampleCode": "@classmethod\\ndef from_json(cls, data):\\n    return cls(data[\"name\"])",
        "exampleSlug": "classmethod-basic"
      }
    },
    "properties": {
      "name": "Properties",
      "concept": "oop",
      "prereqs": ["methods"],
      "teaching": {
        "explanation": "Use @property to create computed attributes. Add @name.setter for write access. Provides encapsulation with attribute syntax.",
        "exampleCode": "@property\\ndef full_name(self):\\n    return f\"{self.first} {self.last}\"",
        "exampleSlug": "property-getter"
      }
    },
    "dataclasses": {
      "name": "Dataclasses",
      "concept": "oop",
      "prereqs": ["classes", "typehints"],
      "teaching": {
        "explanation": "Use @dataclass to auto-generate __init__, __repr__, __eq__. Add field() for defaults. Use frozen=True for immutability.",
        "exampleCode": "from dataclasses import dataclass\\n\\n@dataclass\\nclass User:\\n    name: str\\n    email: str\\n    active: bool = True",
        "exampleSlug": "dataclass-basic",
        "pitfall": {
          "mistake": "Using mutable default values directly in dataclass fields",
          "why": "Same as function defaults - the mutable object is shared across all instances.",
          "fix": "Use field(default_factory=list) for mutable defaults"
        }
      }
    },
    "imports": {
      "name": "Advanced Imports",
      "concept": "modules-files",
      "prereqs": ["imports-basic"],
      "teaching": {
        "explanation": "Organize imports: stdlib, third-party, local. Use `as` for aliases. Understand relative imports in packages.",
        "exampleCode": "from pathlib import Path\\nimport json",
        "exampleSlug": "import-module"
      }
    },
    "reading": {
      "name": "File Reading",
      "concept": "modules-files",
      "prereqs": ["imports"],
      "teaching": {
        "explanation": "Open files with open(path, 'r'). Use read() for all content, readlines() for lines list, readline() for one line.",
        "exampleCode": "with open(\"config.json\") as f:\\n    data = json.load(f)",
        "exampleSlug": "file-open-read"
      }
    },
    "writing": {
      "name": "File Writing",
      "concept": "modules-files",
      "prereqs": ["reading"],
      "teaching": {
        "explanation": "Use open(path, 'w') to write (overwrites), 'a' to append. Use write() for strings, writelines() for lists.",
        "exampleCode": "with open(\"log.txt\", \"a\") as f:\\n    f.write(message + \"\\n\")",
        "exampleSlug": "file-open-write"
      }
    },
    "context": {
      "name": "Context Managers",
      "concept": "modules-files",
      "prereqs": ["reading"],
      "teaching": {
        "explanation": "Use `with open(path) as f:` for automatic cleanup. File closes even if exception occurs. Works with any context manager.",
        "exampleCode": "with open(\"in.txt\") as src, open(\"out.txt\", \"w\") as dst:\\n    dst.write(src.read())",
        "exampleSlug": "context-manager-open"
      }
    },
    "pathlib": {
      "name": "Pathlib",
      "concept": "modules-files",
      "prereqs": ["imports"],
      "teaching": {
        "explanation": "Use Path from pathlib for cross-platform paths. Join with /: `Path('dir') / 'file.txt'`. Methods: exists(), is_dir(), parent.",
        "exampleCode": "config = Path(\"~/.config/app\").expanduser()\\ndata = (config / \"settings.json\").read_text()",
        "exampleSlug": "pathlib-create-path"
      }
    },
    "main-guard": {
      "name": "Main Guard",
      "concept": "modules-files",
      "prereqs": ["imports"],
      "teaching": {
        "explanation": "Use `if __name__ == \"__main__\":` to run code only when script is executed directly, not when imported as module.",
        "exampleCode": "def main():\\n    print(\"Running!\")\\n\\nif __name__ == \"__main__\":\\n    main()",
        "exampleSlug": "main-guard-basic"
      }
    }
  }
}
